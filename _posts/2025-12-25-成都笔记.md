# 成都笔记

# 连接serial

protocol serial
baud rate 115200
![image1-20251225151645-wachc44.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225151954440.png)

# 命令行给 Android 输入框填充

input text "你好"

# IPv6网络模块

```
framework/base/services/java/com/android/server/SystemServer.java
framework/base/services/java/com/android/server/EthernetService.java
framework/base/core/java/android/net/EthernetDataTracker.java -\>startIpv6()-\>runDhcpv6 有线网络
framework/base/ethernet/java/android/net/ethernet/EthernetManager.java
hardware/libhardware_legacy/wifi/wifi.c
external/dhcpcd/
system/core/libnetutils/dhcpv6_utils.c
device/company/project/etc/init_project.rc
```

![image2-20251225151645-y3y9wqo.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225155442340.png)

# adb 连接电视盒子

serial com3下执行
busybox ifconfig 查看盒子 ip
adb root
Windows下执行
adb remout
adb connect 192.168.98.35
adb remount

# mm模块编译

mm -b 编译目标文件夹
看输出日志 Install 对应重新编译的文件
adb push 到 out输出的对应文件夹下

# 如何查看IPv6是否连接

busybox ifconfig
ipv6 link 本地连接地址
ipv6 global 网路连接地址
ps \| grep dhclient
ps \| grep dhcpcd
ps \| grep dh\*
getprop \| grep dh

# 赋予盒子目录读写权限

mount -o remount,rw /system 赋予读写权限 //终端需要先执行su

# WIFI芯片驱动移植

```c
hardware/libhardware_legacy/wifi/wifi.c 108
hardware/libhardware_legacy/wifi/wifi.c 343
hardware/libhardware_legacy/include/hardware_legacy/wifi.h 68

hardware/libhardware_legacy/wifi/wifi.c
static wifi_device_s devices[] = {
    设备ID需要去真实设备查看
	{WIFI_REALTEK_RTL8189FTV.”024c:f129”},
}

#define DRIVER_MODULE_RTL8189FTV  2, \
{\
	通用cfg80211驱动加载
	{“cfg80211”,”/system/lib/modules/cfg80211.ko”,””,”cfg80211”},\
	Wifi驱动8189ftv加载，黄色文字一般与.ko文件保持一致
	{“8189ftv”,”/system/lib/modules/rtl8189ftv.ko”,”ifname=wlan0 if2name=p2p0”,”8189fs”}\
}

#define IS_P2P_SUPPORTED(id)(
	|| WIFI_REALTEK_RTL8189FTV==id
)

Static wifi_modules_s sta_drivers[] = {
	{DRIVER_MODULE_RTL8189FTV},
}

Static wifi_modules_s ap_drivers[] = {
	{DRIVER_MODULE_RTL8189FTV},
}

hardware/libhardware_legacy/include/hardware_legacy/wifi.h

typedef enum{
	数字按照文件内自动增加
	WIFI_REALTEK_RTL8189FTV = 36，
}

Device/goke/Gk6323V100/BoardConfig.mk

# RTL8189FTV
BOARD_BLUETOOTH_WIFI_DEVICE_ RTL8189FTV := n
```

**编译：Hardware\libhardware_legacy mm -b**
**生成文件路径: out/…/system/lib/ libhardware_legacy.so**

# ko文件路径

源码中：device/company/Version/customine/project/gkapi/modules
盒子中：/system/lib/modules \# ls

# WIFI硬件设备ID查看

cat /sys/bus/sdio/devices/mmc1:001:1/uevent
cat /sys/bus/usb/devices/mmc1:001:1/uevent
DRIVER = rtl8189ftv
SDIO_ID = 024c:f179

# 查看驱动是否加载正常

lsmod

# 开启关闭指定服务

setprop ctl.start dhclientDns_eth0 开启指定服务
setprop stl.stop dhclientDns_eth0 停止指定服务

# 查看指定log

logcat -s EthernetDataTracker

# adb命令启动应用

adb shell monkey -p com.android.settings -c android.intent.category.LAUNCHER 1

# 通过包名查看应用名

pm list package -f \|grep 包名

# 查看寄存器

gkmdl 0x1e2e6000 0x200

# iperf参数含义与使用教程

## 1.Iperf参数介绍

| 命令行选项                 | 描述                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **客户端与服务器共用选项** |                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `-f, --format [bkmaBKMA]`  | 格式化带宽数输出。支持的格式有：'b' = bits/sec 'B' = Bytes/sec'k' = Kbits/sec 'K' = KBytes/sec'm' = Mbits/sec 'M' = MBytes/sec'g' = Gbits/sec 'G' = GBytes/sec'a' = adaptive bits/sec 'A' = adaptive Bytes/sec自适应格式是 kilo - 和 mega - 二者之一。除带宽外字段默认输出字节，默认参数为 a。注意：计算字节时 Kilo=1024、Mega=1024²、Giga=1024³；计算比特时 Kilo=1000、Mega=1000²、Giga=1000³，可通过`-f b` 手动计算。示例：`iperf -c 222.35.11.23 -f K` |
| `-i, --interval #`         | 设置每次报告的时间间隔（单位：秒）。非零值会按间隔输出测试报告，默认值为 0。示例：`iperf -c 222.35.11.23 -i 2`                                                                                                                                                                                                                                                                                                                                                |
| `-l, --len #[KM]`          | 设置读写缓冲区长度。TCP 方式默认为 8KB，UDP 方式默认为 1470 字节。示例：`iperf -c 222.35.11.23 -l 16 -m`                                                                                                                                                                                                                                                                                                                                                      |
| `-m, --print_mss`          | 输出 TCP MSS 值（通过 TCP\_MAXSEG 支持）。MSS 值一般比 MTU 值小 40 字节。                                                                                                                                                                                                                                                                                                                                                                                     |
| `-p, --port #`             | 设置端口，需与服务器端监听端口一致。默认是 5001 端口（与 ttcp 相同）。示例：`iperf -s -p 9999`；`iperf -c 222.35.11.23 -p 9999`                                                                                                                                                                                                                                                                                                                               |
| `-u, --udp`                | 使用 UDP 方式而非 TCP 方式，需配合`-b` 选项。                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `-w, --window #[KM]`       | 设置套接字缓冲区大小。TCP 方式为 TCP 窗口大小；UDP 方式为接收数据包缓冲区大小（限制可接收数据包最大值）。                                                                                                                                                                                                                                                                                                                                                     |
| `-B, --bind host`          | 绑定到主机多地址中的一个。客户端：设置出栈接口；服务器端：设置入栈接口（仅多网卡主机有效）。UDP 模式下可绑定并加入多播组（多播地址范围 224.0.0.0 至 239.255.255.255），参考`-T` 参数。                                                                                                                                                                                                                                                                        |
| `-C, --compatibility`      | 兼容低版本 Iperf，无需两端同时开启，但强烈推荐。部分场景下低版本服务器端可能崩溃，需开启此选项。                                                                                                                                                                                                                                                                                                                                                              |
| `-M, --mss #[KM]`          | 通过 TCP\_MAXSEG 尝试设置 TCP 最大信息段值。MSS 通常为 TCP/IP 头减 40 字节（以太网中为 1460 字节，MTU=1500），部分系统不支持。                                                                                                                                                                                                                                                                                                                                |
| `-N, --nodelay`            | 设置 TCP 无延迟选项，禁用 Nagle's 算法（通常交互程序如 telnet 会禁用）。                                                                                                                                                                                                                                                                                                                                                                                      |
| `-V (v1.6+)`               | 绑定 IPv6 地址。服务端：`$ iperf -s –V`客户端：`$ iperf -c  -V`注意：v1.6.3+ 指定 IPv6 无需 `-B` 绑定；v1.6 前需要。多数系统会响应 IPv4 客户端映射的 IPv4 地址。                                                                                                                                                                                                                                                                                             |
| **服务器端专用选项**       |                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `-s, --server`             | 以 Iperf 服务器模式运行                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `-D (v1.2+)`               | Unix 平台：作为后台守护进程运行；Win32 平台：作为服务运行。                                                                                                                                                                                                                                                                                                                                                                                                   |
| `-R (v1.2+, 仅Windows)`    | 卸载 Iperf 服务（若运行中）。                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `-o (v1.2+, 仅Windows)`    | 重定向输出到指定文件。示例：`iperf -c 222.35.11.23 -o c:\iperflog.txt`                                                                                                                                                                                                                                                                                                                                                                                        |
| `-c, --client host`        | 服务器模式下，仅接受指定主机的连接（UDP 模式无效）。                                                                                                                                                                                                                                                                                                                                                                                                          |
| `-P, --parallel #`         | 服务器关闭前保持的连接数，默认 0（永久接受连接）。                                                                                                                                                                                                                                                                                                                                                                                                            |
| **客户端专用选项**         |                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `-b, --bandwidth #[KM]`    | UDP 模式使用的带宽（单位：bits/sec），与`-u` 选项相关，默认值是 1 Mbit/sec。                                                                                                                                                                                                                                                                                                                                                                                  |
| `-c, --client host`        | 以 Iperf 客户端模式运行，连接到指定服务器端。                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `-d, --dualtest`           | 双测试模式：服务器端反向连接客户端（使用`-L` 指定端口，默认用客户端连服务器的端口），双向测试同时完成；如需交互测试，用 `-r` 参数。                                                                                                                                                                                                                                                                                                                           |
| `-n, --num #[KM]`          | 传送的缓冲器数量。默认按 10 秒发送数据，此参数会覆盖限制，按指定次数发送指定长度数据（不计耗时）。参考`-l` 与 `-t` 选项。示例：`iperf -c 222.35.11.23 -n 100000`                                                                                                                                                                                                                                                                                              |
| `-r, --tradeoff`           | 往复测试模式：客户端到服务器测试结束后，服务器反向连接客户端（使用`-l` 指定端口，默认用客户端连服务器的端口），反向连接在客户端连接终止后开始；如需同时双向测试，用 `-d` 参数。                                                                                                                                                                                                                                                                               |
| `-t, --time #`             | 设置传输总时间，Iperf 会在指定时间内重复发送指定长度数据包，默认 10 秒。参考`-l` 与 `-n` 选项。示例：`iperf -c 222.35.11.23 -t 5`                                                                                                                                                                                                                                                                                                                             |
| `-L, --listenport #`       | 指定服务器反向连接客户端时使用的端口，默认用客户端连服务器的端口。                                                                                                                                                                                                                                                                                                                                                                                            |
| `-P, --parallel #`         | 客户端与服务器间使用的线程数，默认 1 线程（需两端同时指定）。                                                                                                                                                                                                                                                                                                                                                                                                 |
| `-S, --tos #`              | 出栈数据包的服务类型（多数路由器忽略）。可指定 16 进制（0x 开头）、8 进制（0 开头）、10 进制值。示例：0x10=020=16；TOS 值 1349 对应：IPTOS\_LOWDELAY (0x10)、IPTOS\_THROUGHPUT (0x08)、IPTOS\_RELIABILITY (0x04)、IPTOS\_LOWCOST (0x02)                                                                                                                                                                                                                       |
| `-T, --ttl #`              | 出栈多播数据包的 TTL 值（路由器跳数），默认 1（链接本地）。                                                                                                                                                                                                                                                                                                                                                                                                   |
| `-F (v1.2+)`               | 使用指定数据流（如文件）测量带宽。示例：`$ iperf -c  -F `                                                                                                                                                                                                                                                                                                                                                                                                     |
| `-I (v1.2+)`               | 与`-F` 功能一致，从标准输入输出文件读取数据。                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **杂项选项**               |                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `-h, --help`               | 显示命令行参考并退出                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `-v, --version`            | 显示版本信息和编译信息并退出                                                                                                                                                                                                                                                                                                                                                                                                                                  |

## 2.TCP客户端和服务器

iperf需要两个系统，因为一个系统必须充当服务端，另外一个系统充当客户端，客户端连接到需要测试速度的服务端
1.在需要测试的电脑上，以服务器模式启动iperf

```
iperf -s
```

可以看到类似于下图的输出

```---
Server listening on TCP port 5001
TCP window size: 85.3 KByte (default)
---
```

2.在第二台设备上，以客户端模式启动iperf连接到第一台电脑ip地址

```
iperf -c 198.51.100.5
```

```---
Client connecting to 198.51.100.5, TCP port 5001
TCP window size: 45.0 KByte (default)
---
\[ 3\] local 198.51.100.6 port 50616 connected with 198.51.100.5 port 5001
\[ ID\] Interval Transfer Bandwidth
\[ 3\] 0.0-10.1 sec 1.27 GBytes 1.08 Gbits/sec
```

3.这时可以在第一步中的服务端终端看到连接和结果，类似下图

```---
Server listening on TCP port 5001
TCP window size: 85.3 KByte (default)
---
\[ 4\] local 198.51.100.5 port 5001 connected with 198.51.100.6 port 50616
\[ ID\] Interval Transfer Bandwidth
\[ 4\] 0.0-10.1 sec 1.27 GBytes 1.08 Gbits/sec
```

## 3.UDP客户端和服务器

使用iperf，还可以测试通过UDP连接实现的最大吞吐量
1.启动UDP iperf服务

```
iperf -s -u
```

```---
Server listening on UDP port 5001
Receiving 1470 byte datagrams
UDP buffer size: 208 KByte (default)
---
```

2.将客户端连接到iperf UDP服务器，以客户端模式启动iperf连接到第一台电脑ip地址

```
iperf -c 198.51.100.5 -u
```

```---
Client connecting to 198.51.100.5, UDP port 5001
Sending 1470 byte datagrams
UDP buffer size: 208 KByte (default)
---
[ 3] local 198.51.100.6 port 58070 connected with 198.51.100.5 port 5001
[ID] Interval Transfer Bandwidth
[ 3] 0.0-10.0 sec 1.25 MBytes 1.05 Mbits/sec
[ 3] Sent 893 datagrams
[ 3] Server Report:
[ 3] 0.0-10.0 sec 1.25 MBytes 1.05 Mbits/sec 0.084 ms 0/ 893 (0%)
```

- 1.05Mbits/sec远低于TCP测试中观察到的值，它也远远低于1GB 的最大出站贷款上限，这是因为默认情况下，iperf讲UDP客户端的贷款限制为每秒1Mbit。
  3.可以用-b标志更改此值，讲数字替换为要测试的最大带宽速率。如果需要测试网络速度，可以将数字设置为高于网络提供商提供的最大带宽上线：
  
  ```
  iperf -c 198.51.100.5 -u -b 1000m
  ```
- 这将告诉客户端我们希望尽可能达到每秒1000Mbits的最大值，该-b标志仅在使用UDP连接时有效，因为iperf未在TCP客户端上设置带宽限制。

```---
Client connecting to 198.51.100.5, UDP port 5001
Sending 1470 byte datagrams
UDP buffer size: 208 KByte (default)
---
[ 3] local 198.51.100.5 port 52308 connected with 98.51.100.5 port 5001
[ID] Interval Transfer Bandwidth
[ 3] 0.0-10.0 sec 966 MBytes 810 Mbits/sec
[ 3] Sent 688897 datagrams
[ 3] Server Report:
[ 3] 0.0-10.0 sec 966 MBytes 810 Mbits/sec 0.001 ms /688896 (0%)
[ 3] 0.0-10.0 sec 1 datagrams received out-of-order
```

## 4.双向测试

在某些情况下，可能希望测试两台服务器以获得最大吞吐量。使用iperf提供的内置双向测试功能可以轻松完成此测试。
1.要测试两个连接，从客户端运行一下命令,ip为服务端ip地址
`iperf -c 198.51.100.5 -d`
2.结果是iperf将在客户端服务器上启动服务器和客户端(198.51.100.6)连接。完成此操作后，iperf会将iperf服务器连接到客户端，该连接现在既充当服务器连接又充当客户端连接。

```---
Server listening on TCP port 5001
TCP window size: 85.3 KByte (default)
---
---
Client connecting to 198.51.100.5, TCP port 5001
TCP window size: 351 KByte (default)
---
[ 3] local 198.51.100.6 port 50618 connected with 198.51.100.5 port 5001
[ 5] local 198.51.100.6 port 5001 connected with 198.51.100.5 port 58650
[ID] Interval Transfer Bandwidth
[ 5] 0.0-10.1 sec 1.27 GBytes 1.08 Gbits/sec
[ 3] 0.0-10.2 sec 1.28 GBytes 1.08 Gbits/sec
```

在服务器，可以看到：

```---
Client connecting to 198.51.100.6, TCP port 5001
TCP window size: 153 KByte (default)
---
[ 6] local 198.51.100.5 port 58650 connected with 198.51.100.6 port 5001
[ 6] 0.0-10.1 sec 1.27 GBytes 1.08 Gbits/sec
[ 5] 0.0-10.2 sec 1.28 GBytes 1.08 Gbits/sec
```

# XXX项目，编译打开wifi配置文件

源码配置文件路径：/device/company/version/customize/xxx/gkapi/customerconfig/gkconf/sdio_gmap.ini
系统配置文件路径：/stbconfig/gkconf/sdio_gmap.ini

```
\#define SDIO_CD_OPT 3 //有WIFI
\#define SDIO_CD_OPT 0 //无WIFI
```

打开支持sdio或者usb版本wifi

# 编译打开Bluetooth配置文件

源码配置文件路径：/device/company/project/bluetooth/realtek8xxx//system/etc/bluetooth/uart/rtkbt.conf
系统配置文件路径：/system/etc/bluetooth/rtkbt.conf
BtDeviceNode=/dev/ttyS2 //打开uart bluetooth
BtDeviceNode=/dev/rtk_btusb //打开usb bluetooth

# 打开kernel日志命令

echo 7 \> /proc/sys/kernel/printk 调试级：调试级别的信息
内核printk的打印级别：[https://blog.csdn.net/sweetfather/article/details/81557730](https://blog.csdn.net/sweetfather/article/details/81557730)
[https://blog.csdn.net/zgxzgxzg/article/details/46774709](https://blog.csdn.net/zgxzgxzg/article/details/46774709)

# 通过U盘烧录boot.img到盒子 uboot

fatload usb 0 0x20200000 boot.img 0xB00000
mmc write.p 0x20200000 boot 0xB00000
uboot 常用命令：[https://blog.csdn.net/luckywang1103/article/details/77865476](https://blog.csdn.net/luckywang1103/article/details/77865476)

# 蓝牙配对流程分析

//需要过滤多个动作，则调用IntentFilter对象的addAction添加新动作

```blueReceiver
IntentFilter foundFilter = new IntentFilter();
foundFilter.addAction(BluetoothDevice.*ACTION_FOUND*);
foundFilter.addAction(BluetoothAdapter.*ACTION_DISCOVERY_FINISHED*);
foundFilter.addAction(BluetoothDevice.*ACTION_BOND_STATE_CHANGED*); //配对状态发生改变广播
foundFilter.addAction(BluetoothDevice.*ACTION_PAIRING_REQUEST*); //配对请求广播
registerReceiver(blueReceiver, foundFilter);
private class BluetoothReceiver extends BroadcastReceiver {
@Override
public void onReceive(Context context, Intent intent) {
String action = intent.getAction();
//根据远程设备所携带的type信息判断是否可以获取到pairingkey，type值通过BluetoothDevice.EXTRA_PAIRING_VARIANT获取到
int type = intent.getIntExtra(BluetoothDevice.*EXTRA_PAIRING_VARIANT*,BluetoothDevice.*ERROR*);
//pairingkey通过BluetoothDevice.EXTRA_PAIRING_KEY获取到
int pairingKey = intent.getIntExtra(BluetoothDevice.*EXTRA_PAIRING_KEY*,BluetoothDevice.*ERROR*);
```

涉及类：
packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothPairingRequest.java 监听action的类
packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothPairingDialog.java 配对弹窗类
frameworks/base/core/java/android/bluetooth/BluetoothDevice.java 用于指代某个蓝牙设备，通常表示对方设备
frameworks/base/core/java/android/bluetooth/IBluetooth.aidl
packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java IBluetooth.aidl实现类

# 遥控器按键集成

![image5-20251225151645-ofea891.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225165900948.png)
图一：遥控器按键码值匹配图
**源代码文件路径：/device/company/project/customize/hebei_ipbox/chuangpin/gkapi/customerconfig/gkconf/Irsetting.ini**
**系统文件路径：/stbconfig/gkconf /Irsetting.ini**

```[Kernel]
0=KIR_versionTV
1=KIR_versionFJ
2=KIR_JIUZHOU
3=KIR_HeBei
4=KIR_HBIPBox //添加自己的遥控器名称
\[KIR_HBIPBox\] //遥控器名称
Enable=true \#true or false
Protocol=0x01
Header=0x01fd //客户码(0x代表16进制) 查看遥控器按键码值匹配图。
Keymap= KIR_HBIPBox_Keymap //按键映射名称
\[KIR_HBIPBox_Keymap\] //按键映射名称
KEY_POWER = 0xdc 查看遥控器按键码值匹配图。 (0x代表16进制)
KEY_MUTE = 0x9c 同上
KEY_0 = 0x87
KEY_1 = 0x92
KEY_2 = 0x93
KEY_ESC = 0xc5
KEY_UP = 0xca
KEY_DOWN = 0xd2
KEY_LEFT = 0x99
KEY_RIGHT = 0xc1
KEY_MENU = 0x98
KEY_VOLUMEUP = 0xdd
KEY_VOLUMEDOWN = 0x8c
KEY_BACK = 0x82
KEY_ENTER = 0xce
```

其他按键添加也遵循此方法，但是一定要key与value匹配。

# 终止Thread线程的方法。

终止线程的三种方法
1\. 使用退出标志，使线程正常退出，也就是当方法完成后线程终止。
public volatile boolean exit = false;
myThread.exit = true;
一定要用volatile，这样程序就会一直检查volatile的值，且不会在多线程中复制，而是共享。
2\. 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。
myThread.stop();
3\. 使用interrupt方法中断线程。
myThread.interrupt();

# TVOS客户目录与版本建立

1.cd device/company/project/customize
2.复制一个客户项目如hunan
3.gkapi是驱动释放的
4.修改所有包含hunan字眼的product_target
5\. version/BoadConfigCommon.mk
version/device.mk
build/config/project_cfg.mk
scripts/目录下所有差异
6.第一次编译没有release环境，只能先编译development环境
source build/envsetup.sh
lunch
userdebug
./device/company/version/build/scripts/switch_dev_release.sh
先选择development
git diff ./device/company/version/build/config/project_cfg.mk 可以看到此文件已发生变化
lunch 因为变化了一定要lunch
make -j32
对比sdk下source/gkapi/source/out/release/gkapi目录输出与customize/定制目录/gkapis是否相同
编译完成
./device/company/version/build/scripts/switch_dev_release.sh
install
这样就编译检查完成
./device/company/version/build/scripts/switch_dev_release.sh
release
lunch
userdebug
检查release版是否可以编译成功

# wifi灯的驱动代码控制

![image6-20251225151645-9lt2t0y.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225170413565.png)
WIFI_LED针脚定义图
1.在wifi_led针脚定义图中可以看到，这个wifi_led是通过GPIO1控制的。
2\. GPIO1的控制代码路径:

```/device/company/project/sdk/source/gkapi/source/customize/an_gansu/include/gkbsp/gdrv_gpio.h
\#define PIN_GPIOI 42
```

3.GPIO1的上层引用代码控制路径：
`/device/company/project/customize/ip_gansu/gkapi/customerconfig/gkconf/front_panel_config`
![image7-20251225151645-38a9tdl.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225170635684.png)
4.0-5所代表具体操作灯状态定义如下：
`/bootable/recovery/keyled/keyled_recovery.h`
![image8-20251225151645-srdamzy.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225170714463.png)
3.在盒子控制wifi_led灯的位置如下：
`stbconfig /gkconf/front_panel_config`
总结：如果要修改其他盒子的wifi_led灯控制，只需要修改KEYLED_SINGLE_LED_3所操作的数字3所对应的数字（如：42）即可，而42所代表的含义就是wifi_led所定义的针脚数字，具体是那个针脚需要在图纸上查看，然后在gdrv_gpio.h查看定义数字，修改即可。

# 进入升级模式的几种方式

1.ok+0，开机上电进入recovery模式，先清除数据，再升级（同一系统，不区分高低版本升级）。
2.ok+2，开机上电进入GkUpgrade.bin升级，不区分系统和版本。
3.U盘根目录创建upgrade文件夹存入update.zip(同一系统，不区分版本号)。
4.串口，开机上电不断按电脑enter，输入ucompany进入GkUpgrade.bin升级，不区分系统和版本

# 查看网络连接状态

有线：
logcat \| grep "ConnectivityService"
logcat \| grep "updateNetworkInfo"
无线：
logcat \| grep "WifiHW"
logcat \| grep "WifiStateMachine"

# 设置系统属性打开adb

setprop sys.usb.config adb
setprop persist.service.adb.enable true

# led灯控制文件

ghal_api_frontpanel.h
ghal_api_frontpanel.cpp
GHAL_FRONTPANEL_开头的接口，如GHAL_FRONTPANEL_SetSingleLed
编译更新libgk_ssp.so

# 替换out/…/app直接编译GkUpgrade.bin

1.在out/…/app下替换需要不用系统签名的app
2.make snod
3.device/company/project/build/scripts/releaseALLImage.sh
4\. device/company/project/build/scripts/createUsbUpgradeBin.sh

# 看编译版本信息

echo version\>/proc/gkbsp

# 查看tombstone日志，crash地址所在行

如：

```backtrace:
\#00 pc 0001bc82 /system/lib/libDTVClient.so (android::InterDTVScanParamS::~InterDTVScanParamS()+71)
\#01 pc 000181f1 /system/lib/libDTVClient.so (android::CHDTVClient::~CHDTVClient()+72)
**\#02 pc 00018759 /system/lib/libDTVClient.so (android::CHDTVClient::getInstance()+44)**
\#03 pc 0001e003 /system/lib/libDTVClient.so (DTVAL_getTunerStatus(int)+6)
\#04 pc 0001dbcc /system/lib/libdvm.so (dvmPlatformInvoke+112)
\#05 pc 0004e123 /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const\*, JValue\*, Method const\*, Thread\*)+398)
\#06 pc 00000214 /dev/ashmem/dalvik-jit-code-cache (deleted)
```

`\$ cd out/target/product/version/symbols/system/lib`
`\$ addr2line -e libDTVClient.so 00018759`

# Android Framework添加自定义接口

## 1.定义Java接口

在 frameworks/base/core/java目录下，根据包名创建一个子目录，比如我创建的是com\gcable\system\upgrade，在该目录下，新建一个java文件，比如UpgradeBoot.java ，对应的代码如下：

```java
private static final String TAG = "UpgradeBoot";
public static synchronized Boolean upgradeBootAnimation(UpgradeBoot.BootAnimationType bootAnimationType, File updateImgFile, UpgradeBoot.FileType fileType) {
try {
Log.d("UpgradeBoot", "upgradeBootAnimation: start");
if (updateImgFile != null) {
if (UpgradeBoot.BootAnimationType.BOOT_PIC == bootAnimationType) {
Log.d("UpgradeBoot", "upgradeBootAnimation: 修改开机 boot 阶段 LOGO");
} else if (UpgradeBoot.BootAnimationType.BOOT_ANIMATION == bootAnimationType) {
Log.d("UpgradeBoot", "upgradeBootAnimation: 修改开机Android 阶段动态图片帧");
}
return false;
} else {
Log.d("UpgradeBoot", "upgradeBootAnimation: 表示清空 A 类广告，包括 logo和 bootanimation");
return false;
}
} catch (Exception e) {
e.printStackTrace();
throw new RuntimeException("Stub");
}
}
public static enum FileType {
BOOT_IMAGE,
BOOT_VIDEO;
}
public static enum BootAnimationType {
BOOT_PIC,
BOOT_ANIMATION;
}
}
```

## 2.编译接口

上面虽然定义了两个文件，但是默认情况下，编译Android的时候是不会编译到这两个文件的，如果要用编译到对应的文件，需要修改frameworks/base/Android.mk文件，在对应的LOCAL_SRC_FILES宏中添加对应的文件即可，相应的patch文件如下：

```LOCAL_SRC_FILES
packages/services/Proxy/com/android/net/IProxyPortListener.aidl \\
core/java/android/os/IDisplayDeviceManagementService.aidl \\
core/java/com/gcable/system/upgrade/UpgradeBoot.java
```

## 3.编译更新接口

编译源码，因为添加了接口，所以需要
`make update-api`

## 4.部分编译framework代码

```
\$ cd frameworks/base/core/java /core/java/com/gcable/system/upgrade/
\$ mm -B
```

## 5.拷贝编译生成的源码classes.jar

拷贝编译生成的源码class.jar到Android studio工程中看是否能使用
`\$ filecheck out/target/common/obj/JAVA_LIBRARIES/framework2_intermediates/classes.jar`
以下是classes.jar重命名的framework2.jar
![image9-20251225151645-yfvxm4p.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225171200695.png)

## 6.拷贝编译包含新接口的framework2.jar替换盒子/system/framework目录下文件

拷贝framework2.jar到盒子相应的目录下，目的是让使用新接口的app可以在盒子中调用到真正的framework接口。
参考链接：[https://blog.csdn.net/u013638184/article/details/88218600](https://blog.csdn.net/u013638184/article/details/88218600)
[https://www.cnblogs.com/rossoneri/p/9651782.html](https://www.cnblogs.com/rossoneri/p/9651782.html)

# 通过tftp烧录系统

1.查看电脑ip
2.把需要推送的文件夹指定到如下图所示：
![image10-20251225151645-y9w8ygt.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225171319429.png)
3.uboot阶段设置服务器ip和客户端ip

```
$ printenv 查看参数设置
$setenv serverip 192.168.98.92(查看的电脑ip)
$saveenv
$setenv ipaddr 192.168.98.249(设置一个未使用的ip)
$saveenv
$company auto_update.txt
```

# handleReceiver处理静态广播

frameworks/base/core/java/android/app/ActivityThread.java

```java
private void handleReceiver(ReceiverData data) {
String component = data.intent.getComponent().getClassName();
LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo);
IActivityManager mgr = ActivityManagerNative.getDefault();
ActivityThread. scheduleReceiver处理应用进程中接收到的静态广播消息，实际处理该广播的是ActivityThread.handleReceiver函数。处理主要包含3大步骤：
1） 创建BroadcastReveiver对象
BroadcastReceiver receiver;
...
try {
Application app = packageInfo.makeApplication(false, mInstrumentation);
if (localLOGV) Slog.v(
TAG, "Performing receive of " + data.intent
- ": app=" + app
- ", appName=" + app.getPackageName()
- ", pkg=" + packageInfo.getPackageName()
- ", comp=" + data.intent.getComponent().toShortString()
- ", dir=" + packageInfo.getAppDir());
  //Performing receive of Intent { act=android.intent.action.MEDIA_UNMOUNTED dat=file:///mnt/sda/sda4 flg=0x10 cmp=com.company.usbservicetest/.USBReceivers (has extras) }
  // : app=android.app.Application@427d7118,
  // appName=com.company.usbservicetest,
  // pkg=com.company.usbservicetest,
  // comp={com.company.usbservicetest/com.company.usbservicetest.USBReceivers},
  // dir=/data/app/com.company.usbservicetest-1.apk
  首先从AMS传递的intent中获取当前处理该广播的组件名称，然后通过反射创建一个BroadcastReveiver对象，从这里可以看出来，静态广播处理的时候，每次都会创建一个新的BroadcastReveiver对象；
  2） 执行onReceive函数
  ContextImpl context = (ContextImpl)app.getBaseContext();
  sCurrentBroadcastIntent.set(data.intent);
  receiver.setPendingResult(data);
  receiver.onReceive(context.getReceiverRestrictedContext(),
  data.intent);
  } catch (Exception e) { }
  3） 向AMS发送处理结束消息
  if (receiver.getPendingResult() != null) {
  data.finish();
  }
  }
```

## 1.拦截特定静态广播：

通过包名阻止特定应用接收特定广播，并通过属性控制，是否打开。

```java
String target = SystemProperties.get("persist.test.usb","false");
ContextImpl context = (ContextImpl)app.getBaseContext();
sCurrentBroadcastIntent.set(data.intent);
receiver.setPendingResult(data);
if("com.company.usbservicetest".equals(packageInfo.getPackageName())&&"false".equals(target)){
Log.*d*(*TAG*, "拦截此应用接收此广播");
}else{
receiver.onReceive(context.getReceiverRestrictedContext(),
data.intent);
}
```

参考链接：[https://blog.csdn.net/houliang120/article/details/51607170](https://blog.csdn.net/houliang120/article/details/51607170)

# 正则表达式匹配关键字所在行

^.\*关键字.\*\$

# so文件编译生成与应用

## 1.建立文件目录结构如下

```
├── Android.mk
├── chipid_properties
│-- ├── Android.mk
│-- ├── ChipidProperties.cpp
│-- └── ChipidProperties.h
```

## 2.上级Android.mk定义规则

```
LOCAL_PATH := \$(call my-dir)
include \$(call all-makefiles-under,\$(LOCAL_PATH))
```

## 3. Android.mk 文件定义

```sh
LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := libChipidProperties     //模块名，最终生成libChipidProperties.so
ALL_DEFAULT_INSTALLED_MODULES += $(LOCAL_MODULE)
LOCAL_PRELINK_MODULE := false
LOCAL_MODULE_TAGS := optional

LOCAL_SRC_FILES:= \
    ChipidProperties.cpp    //源代码文件

LOCAL_C_INCLUDES += \
    $(LOCAL_PATH) \
    device/goke/kunpeng/sdk/source/ssp/include \  //需要用到的头文件路径 如:#include "ghal_api_sys.h"
    $(TARGET_GKAPI_INC)

LOCAL_SHARED_LIBRARIES := \
    libui \
    libutils \
    libcutils \
    libbinder \
    libgk_ssp  //需要用到的动态库文件名，如ghal_api_sys.h在libgk_ssp.so这个动态库里面
    
include $(BUILD_SHARED_LIBRARY)  //定义为编译动态库
```

## 4.ChipidProperties.h 头文件定义

```cpp
#ifdef __cplusplus     //用于别人引用代码
extern "C" {
#endif
    int chipid_properties_get(char* buffer, int bufSize);
    int chipid_properties_set(const char* value);
#ifdef __cplusplus
}
#endif
```

## 5.ChipidProperties.cpp 文件定义

```cpp
#include "ghal_api_sys.h"
#include "ChipidProperties.h"

#ifdef __cplusplus
extern "C" {
#endif

int chipid_properties_get(char* buffer, int bufSize)
{
}

int chipid_properties_set(const char* value)
{
}

#ifdef __cplusplus
}
#endif
```

## 6.在chipid_properties下执行mm -b编译

# 可执行文件生成与应用

## 1.建立文件目录结构如下

```
├── Android.mk
├── device_properties_service
│     ├── Android.mk
└── TestDevicePropertiesService.cpp
```

## 2.上层Android.mk 定义

`include \$(all-subdir-makefiles)`

## 3.Android.mk 文件定义

```sh
LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := DevicePropertiesService_Test  //生成可执行文件名
ALL_DEFAULT_INSTALLED_MODULES += $(LOCAL_MODULE)
LOCAL_PRELINK_MODULE := false
LOCAL_MODULE_TAGS := optional

LOCAL_C_INCLUDES += \
    $(LOCAL_PATH) \
    $(LOCAL_PATH)/include \
  device/goke/kunpeng/system/libraries/chipid_properties \ //需要用到的头文件路径 如:#include "ChipidProperties.h"
LOCAL_SRC_FILES:= \
TestDevicePropertiesService.cpp  //源代码文件

LOCAL_SHARED_LIBRARIES := \
    libui \
    libutils \
    libcutils \
    libbinder \
    libDeviceProperties \
    libChipidProperties  //需要用到的动态库文件名，如ChipidProperties.h在libChipidProperties.so这个动态库里面

include $(BUILD_EXECUTABLE)  //定义为编译生成可执行文件
```

## 4.TestDevicePropertiesService.cpp 定义

```cpp
#include "ChipidProperties.h"
int main(int argc, char** argv)
{
    if (argc == 3 && strcmp(argv[1], "get") == 0){
    } else if (argc == 4 && strcmp(argv[1], "set") == 0){
    }
    return 0;
}
```

## 5.在device_properties_service下执行mm -b编译

# Binder进程间通信实例

## 1. 建立文件目录结构如下

```
├── Android.mk
├── binder
├── Android.mk
├── cur_log.h
├── IMyService.cpp
├── IMyService.h
├── MyClient.cpp
└── MyServer.cpp
```

## 2. 上层Android.mk 定义

`include \$(all-subdir-makefiles)`

## 3. Android.mk 文件定义

```bash
LOCAL_PATH := $(call my-dir)
 
####################
# MyService
####################
include $(CLEAR_VARS)
LOCAL_SRC_FILES := IMyService.cpp \
                     MyServer.cpp
 
LOCAL_C_INCLUDES += $(LOCAL_PATH) \
 
LOCAL_SHARED_LIBRARIES := libc libutils libcutils liblog libbinder
 
LOCAL_MODULE := MyService
include $(BUILD_EXECUTABLE)
 
####################
# Myclient
####################
include $(CLEAR_VARS)
LOCAL_SRC_FILES := IMyService.cpp \
                     MyClient.cpp
 
LOCAL_C_INCLUDES += $(LOCAL_PATH) \
 
LOCAL_SHARED_LIBRARIES := libc libutils libcutils liblog libbinder
 
LOCAL_MODULE := MyClient
include $(BUILD_EXECUTABLE)
```

## 4. cur_log.h 打印信息头文件

```h
#ifndef CUR_LOG_H
#define CUR_LOG_H
 
#include <android/log.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
 
#ifdef __cplusplus
extern "C" {
#endif
 
#undef  LOG_TAG
#define LOG_TAG "binder_test"
 
#define cur_logi(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)  /* 普通打印信息 */
#define cur_loge(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__) /* 错误打印信息 */
// #define cur_logi(fmt, args...)  printf("I %s " fmt "\n", LOG_TAG, ##args)
// #define cur_loge(fmt, args...)  printf("E %s " fmt "\n", LOG_TAG, ##args)
#define cur_enter() cur_logi("enter %s", __func__)
#define cur_exit()  cur_logi("exit %s", __func__)
 
#ifdef __cplusplus
}
#endif
 
/* CUR_LOG_H */
#endif
```

## 5. IMyService.h客户端/服务端业务接口声明

```cpp
#ifndef IMYSERVICE_H
#define IMYSERVICE_H
 
#include "cur_log.h"
#include <binder/IInterface.h>
#include <binder/Parcel.h>
#include <utils/String8.h>
#include <utils/String16.h>
 
#define MY_SERVICE "coder.Myservice"
 
using namespace android;
namespace android
{
 
// 声明业务接口, Bp Bn 继承 业务接口
    class IMyService : public IInterface
    {
    public:
        // 定义命令字段
        enum
        {
            // SEND_INT = 0 ， 可自定义
            SEND_INT = IBinder::FIRST_CALL_TRANSACTION,
            GET_STRING,
            GET_INT,
            SAY_HELLO,
        };
        // 使用宏，声明 MyService 业务接口，将业务和通信牢牢地钩在了一起
        DECLARE_META_INTERFACE(MyService);
        // 声明方法
        virtual void sendInt(int32_t val) = 0;
        virtual String8 getString() = 0;
        virtual int32_t getInt() = 0;
        virtual void sayHello() = 0;
    };
 
// 声明客户端 BpMyService
    class BpMyService : public BpInterface<IMyService>
    {
    public:
        BpMyService(const sp<IBinder>& impl);
        ~BpMyService();
        virtual void sendInt(int32_t val);
        virtual String8 getString();
        virtual int32_t getInt();
        virtual void sayHello();
 
    };
 
   // 声明服务端 BnMyService
    class BnMyService : public BnInterface<IMyService>
    {
    public:
        // BnXXService实现了onTransact函数，它将根据消息码调用对应的业务逻辑函数
        virtual status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags = 0);
        BnMyService();
        ~BnMyService();
        virtual void sendInt(int32_t val);
        virtual String8 getString();
        virtual int32_t getInt();
        virtual void sayHello();
    private:
        int32_t option;
    };
}
#endif
```

## 6. IMyService.cpp客户端/服务端实现

```cpp
#include "IMyService.h"
#include <binder/IPCThreadState.h>
#include <binder/Parcel.h>
 
namespace android
{
  // 实现 IMPLEMENT_META_INTERFACE 宏模板定义 MyService 业务接口， 将业务和通信牢牢地钩在了一起
    IMPLEMENT_META_INTERFACE(MyService, MY_SERVICE);
 
    /***********************************************************************************
     *   客户端
    */
        BpMyService::BpMyService(const sp<IBinder>& impl) : BpInterface<IMyService>(impl)
        {
        }
        BpMyService::~BpMyService() {};
        void BpMyService::sendInt(int32_t val)
        {
            Parcel data, reply;
            data.writeInterfaceToken(IMyService::getInterfaceDescriptor());
            data.writeInt32(val);
            remote()->transact(SEND_INT, data, &reply);
        }
 
        String8 BpMyService::getString()
        {
            Parcel data, reply;
            data.writeInterfaceToken(IMyService::getInterfaceDescriptor());
            remote()->transact(GET_STRING, data, &reply);
            String8 res = reply.readString8();
            return res;
        }
 
        int32_t BpMyService::getInt()
        {
            Parcel data, reply;
            data.writeInterfaceToken(IMyService::getInterfaceDescriptor());
            remote()->transact(GET_INT, data, &reply);
            int32_t val = reply.readInt32();
            return val;
        }
        void BpMyService::sayHello()
        {
            Parcel data, reply;
            data.writeInterfaceToken(IMyService::getInterfaceDescriptor());
            remote()->transact(SAY_HELLO, data, &reply);
            int32_t val = reply.readInt32();
            printf("say hello %d \n", val);
 
        }
 
    /*************************************************************************************
    *  服务端
    */
    BnMyService::BnMyService()
    {
        option = 0;
    }
    BnMyService::~BnMyService(){}
    
    /* 接收远程消息，处理 onTransact 方法 */
    status_t BnMyService::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
    {
        switch(code)
        {
            case SEND_INT:
                {
                    CHECK_INTERFACE(IMyService, data, reply);
                    int32_t val = data.readInt32();  // 调用服务类的函数
                    sendInt(val);
                    return NO_ERROR;
                }
                break;
            case GET_STRING:
                {
                    CHECK_INTERFACE(IMyService, data, reply);
                    String8 res = getString(); // 调用服务类的函数
                    reply->writeString8(res);
                    return NO_ERROR;
                }
                break;
            case GET_INT:
                {
                    CHECK_INTERFACE(IMyService, data, reply);
                    int32_t val = getInt(); // 调用服务类的函数
                    reply->writeInt32(val);
                    return NO_ERROR;
                }
                break;
            case SAY_HELLO:
                {
                    CHECK_INTERFACE(IMyService, data, reply);
                    sayHello();
                    reply->writeInt32(2019);
                    return NO_ERROR;
                }
                break;
            default:
                return BBinder::onTransact(code, data, reply, flags);
        }
 
    }
 
    void BnMyService::sendInt(int32_t val)
    {
        option = val;
    }
 
    int32_t BnMyService::getInt()
    {
        return option;
    }
 
    String8 BnMyService::getString()
    {
        String8 str;
        if(option <= 0)
        {
            str = String8("val <= 0");
        }
        else
        {
            str = String8("val > 0 ");
        }
        return str;
    }
    void BnMyService::sayHello()
    {
        printf("Hello, %s\n", __func__);
    }
}
```

## 7. MyServer.cpp注册 service 到系统

```cpp
#include "IMyService.h"
#include <binder/IServiceManager.h>
#include <binder/IPCThreadState.h>
 
int main(int argc __unused, char *argv[] __unused)
{
    sp < IServiceManager > sm = defaultServiceManager(); //获取service manager引用
    sm->addService(String16(MY_SERVICE), new BnMyService()); // 注册 MySerivce 服务到系统中

    // 开启线程池，接收处理Client发送的进程间通信请求
    ProcessState::self()->startThreadPool();  //启动线程池
    IPCThreadState::self()->joinThreadPool(); //把主线程加入线程池
    return 0;
}
```

## 8. MyClient.cpp客户端调用

```cpp
#include "IMyService.h"
#include <binder/IServiceManager.h>
 
int main()
{
    sp < IServiceManager > sm = defaultServiceManager(); //获取service manager引用
    sp < IBinder > binder = sm->getService(String16(MY_SERVICE));//获取名为 "coder.Myservice" 的binder接口
    if(binder == NULL)
    {
        cur_loge("error, binder = NULL %s", __func__);
        return -1;
    }
 
    // 获取 client <--> service
    sp<IMyService> service = IMyService::asInterface(binder);
    if(service == NULL)
    {
        cur_loge("error, service = NULL %s", __func__);
    }
    for(int32_t i = 0; i < 10; i++)
    {
        service->sendInt(-i);
        String8 str1 = service->getString();
        cur_logi("val = %d, str1 : %s", service->getInt(), str1.string());
 
        service->sendInt(i);
        String8 str2 = service->getString();
        cur_logi("val = %d, str2 : %s", service->getInt(), str2.string());
    }
    service->sayHello();
    return 0;
}
```

## 9. 测试方法如下：

MyService &   # 运行服务
MyClient      # 运行测试
参考链接：[https://blog.csdn.net/qq_38907791/article/details/89576209](https://blog.csdn.net/qq_38907791/article/details/89576209)

# Android cpp添加LOG打印

## 1.头文件引入

```cpp
#include <android/log.h>
#define LOG_NDEBUG 0
#define LOG_TAG "log_head"

打开ALOGV: #define LOG_NDEBUG 0
打开ALOGI：#define LOG_NIDEBUG 0
打开ALOGD：#define LOG_NDDEBUG 0
printf("[%s(%d)<%s>]", __FILE__, __LINE__, __FUNCTION__);
__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, "Print output: %s", outputString);
```

## 2. 加入跟日志相关的动态库liblog libutils

`LOCAL_SHARED_LIBRARIES := liblog libutils`

# 设置屏蔽显示图形层

setprop company.disable.osd 1

# NDK开发-JNI调用java层代码

## 1.java中native代码如下：

```java
package com.gebilaolitou.jni;
import android.util.Log;
public class JNITools {
private static final String *TAG* = "JNITools";
static {
System.*loadLibrary*("jnidemo3");
}
private int ae,be;
public JNITools(){
ae=2;be=2;
Log.*d*(*TAG*, "JNITools: run");
}
public int addn(int a ,int b){
return ae+be;
}
//加法
public native int add(int a,int b);
//减法
public static native int sub(int a,int b);
//乘法
public static native int mul(int a,int b);
//除法
public static native int div(int a,int b);
}
```

## 2.jni层代码如下：

```cpp
#include <jni.h>
#include <android/log.h>
#include <stdio.h>
#include <stdlib.h>

jint addNumber(JNIEnv *env,jclass clazz,jint a,jint b);
jint subNumber(JNIEnv *env,jclass clazz,jint a,jint b);
jint mulNumber(JNIEnv *env,jclass clazz,jint a,jint b);
jint divNumber(JNIEnv *env,jclass clazz,jint a,jint b);

JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved){
    //打印日志，说明已经进来了
    __android_log_print(ANDROID_LOG_DEBUG,"JNITag","enter jni_onload");
    JNIEnv* env = NULL;
    jint result = -1;
    // 判断是否正确
    if((*vm)->GetEnv(vm,(void**)&env,JNI_VERSION_1_6)!= JNI_OK){
        return result;
    }
    //注册四个方法，注意签名
    const JNINativeMethod method[]={
            {"add","(II)I",(void*)addNumber},
            {"sub","(II)I",(void*)subNumber},
            {"mul","(II)I",(void*)mulNumber},
            {"div","(II)I",(void*)divNumber}
    };
    //找到对应的JNITools类
    jclass jClassName=(*env)->FindClass(env,"com/gebilaolitou/jni/JNITools");
    //开始注册
    jint ret = (*env)->RegisterNatives(env,jClassName,method, 4);
     //如果注册失败，打印日志
    if (ret != JNI_OK) {
        __android_log_print(ANDROID_LOG_DEBUG, "JNITag", "jni_register Error");
        return -1;
    }
    return JNI_VERSION_1_6;
}

jint addNumber(JNIEnv *env,jobject object,jint a,jint b){
    //获取JNITools类的class引用
    jclass clazz= (*env)->FindClass(env,"com/gebilaolitou/jni/JNITools");
    //获取类JNITools中addn方法的id
    jmethodID addn =  (*env)->GetMethodID(env, clazz, "addn", "(II)I");
    //获取类JNITools中构造方法的id
    jmethodID  init = (*env)->GetMethodID(env, clazz,"<init>","()V");
    //获取类JNITools的对象实例
    jobject obj = (*env)->NewObject(env,clazz, init);
    //获取类JNITools中ae,be属性的id
    jfieldID ae =  (*env)->GetFieldID(env, clazz, "ae", "I");
    jfieldID be =  (*env)->GetFieldID(env, clazz, "be", "I");
    jint ae_int = (*env)->GetIntField(env,object,ae);
    jint be_int = (*env)->GetIntField(env,object,be);
    __android_log_print(ANDROID_LOG_DEBUG,"JNITag","ae_int=%d,be_int=%d",ae_int,be_int);
    if(ae_int==a){
        (*env)->SetIntField(env,obj,ae,5);
        __android_log_print(ANDROID_LOG_DEBUG,"JNITag","ae_int==a");
    }
    if(be_int==b){
        (*env)->SetIntField(env,obj,be,5);
        __android_log_print(ANDROID_LOG_DEBUG,"JNITag","be_int==b");
    }
    //调用类的addn方法
    jint  result = (*env)->CallIntMethod(env,obj,addn,a,b);
    //检测调用是否异常
    if ((*env)->ExceptionCheck(env)) {
        __android_log_print(ANDROID_LOG_DEBUG,"JNITag","CallIntMethod时发生错误");
    }
    __android_log_print(ANDROID_LOG_DEBUG,"JNITag","result:%d",result);
    // 删除局部引用（jobject或jobject的子类才属于引用变量），允许VM释放被局部变量所引用的资源
    (*env)->DeleteLocalRef(env, clazz);
    (*env)->DeleteLocalRef(env, obj);
     return result;

}

jint subNumber(JNIEnv *env,jclass clazz,jint a,jint b){
     return a-b;
}
jint mulNumber(JNIEnv *env,jclass clazz,jint a,jint b){
     return a*b;
}
jint divNumber(JNIEnv *env,jclass clazz,jint a,jint b){
     return a/b;
}
```

## 3.参考链接：

[NDK-Java与native的互相调用](https://27house.cn/archives/1101) [JNI实现回调| JNI调用JAVA函数|参数和返回值的格式](https://blog.csdn.net/stefzeus/article/details/6721346)
[JNI 调用Java属性和方法](https://blog.csdn.net/u011974987/article/details/52745362)
[调用构造方法和父类实例方法](https://blog.csdn.net/xyang81/article/details/44002089)

## 4.系列学习链接：

[Android JNI(一)——NDK与JNI基础](https://www.jianshu.com/p/87ce6f565d37)
[JNI/NDK入门指南之正确姿势了解JNI和NDK](https://blog.csdn.net/tkwxty/article/details/103454842)
[CMAKE手册](https://www.zybuluo.com/khan-lau/note/254724)

# JNI-查看类中的方法的签名的命令

`javap -s -p MainActivity.class`

# 自定义view的流程

![image11-20251225151645-80dfztb.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172240904.png)
![image12-20251225151645-01kmtdu.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172301772.png)
![image13-20251225151645-vxukfh6.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172318724.png)
![image14-20251225151645-0xiyebp.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172329604.png)
![image15-20251225151645-kjmwj7p.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172340491.png)
![image16-20251225151645-gdd6887.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172401682.png)

# view的创建流程

![image17-20251225151645-7telplt.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172426727.png)
![image18-20251225151645-84cgn63.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172440214.png)## 1. performLaunchActivity();

```
Activity. setContentView()
generateDecor()
generateLayout()
//从主题文件中获取样式信息
//加载窗口布局
//加载layoutResource
//往DecorView中添加子View
```

## 2. handleResumeActivity()

![image19-20251225151645-y8x6x61.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172538270.png)

### 2.1 performTraversals()

```java
private void performTraversals() {
 //获得view宽高的测量规格，mWidth和mHeight表示窗口的宽高，lp.width和lp.height表示DecorView根布局宽和高
     WindowManager.LayoutParams lp = mWindowAttributes;
     ...
        //顶层视图DecorView所需要窗口的宽度和高度
        int desiredWindowWidth;
        int desiredWindowHeight;
     ...
        //在构造方法中mFirst已经设置为true，表示是否是第一次绘制DecorView
        if (mFirst) {
            mFullRedrawNeeded = true;
            mLayoutRequested = true;
         //如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要窗口的宽度和高度就是除了状态栏
            if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL
                    || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {
                // NOTE -- system code, won't try to do compat mode.
                Point size = new Point();
                mDisplay.getRealSize(size);
                desiredWindowWidth = size.x;
                desiredWindowHeight = size.y;
            } else {//否则顶层视图DecorView所需要窗口的宽度和高度就是整个屏幕的宽高
                DisplayMetrics packageMetrics =
                    mView.getContext().getResources().getDisplayMetrics();
                desiredWindowWidth = packageMetrics.widthPixels;
                desiredWindowHeight = packageMetrics.heightPixels;
            }
    }
    ...
     int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
     int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
     ...
     // Ask host how big it wants to be
     //执行测量操作
     performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
      ...
     //执行布局操作
    performLayout(lp, mWidth, mHeight);
     ...
     //执行绘制操作
     performDraw();
}
//ViewRootImpl
private static int getRootMeasureSpec(int windowSize, int rootDimension) {
 DecorView, 其MeasureSpec由窗口尺寸和其自身LayoutParams共同决定，
}
//ViewGroup
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
   普通View，其MeasureSpec由父容器的MeasureSpec和自身的LayoutParams共同决定。
}
```

#### 2.1.1 measure整体执行流程：

![image20-20251225151645-xrufr1d.jpeg](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172647560.png)#### 2.1.2 layout的整体执行流程：
![image21-20251225151645-67wfcu7.jpeg](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172709841.png)#### 2.1.3 draw整体执行流程：
![image22-20251225151645-71f3u8g.jpeg](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172726738.png)## invalidate/postInvalidate 和 requestLayout
![image23-20251225151645-igiw5q2.jpeg](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172746024.png)## Activity、Window、View关系总结
![image24-20251225151645-691swdm.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172804259.png)## Surface创建过程：
![image25-20251225151645-gglvlbi.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172824942.png)

## SurfaceFlinger启动及图层合成送显过程

![image26-20251225151645-j8flkwo.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225172946761.png)## View的绘制总流程
![image27-20251225151645-oc0wvks.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173020911.png)

# 系统属性property底层执行流程

`system/core/init/init.c`

```cpp
int main(int argc, char **argv)  {  
    ......  
    for(;;) {  
        ......  
        if (!property_set_fd_init && get_property_set_fd() > 0) {  
            ufds[fd_count].fd = get_property_set_fd();  
            ufds[fd_count].events = POLLIN;  
            ufds[fd_count].revents = 0;  
            fd_count++;  
            property_set_fd_init = 1;  
        }  
        ......
    }  
    return 0;  
}
```

处理系统属性变化事件。当我们调用函数property_set来改变一个系统属性值时：
1.系统就会通过一个socket（通过调用函数get_property_set_fd可以获得它的文件描述符）来向init进程发送一 个属性值改变事件通知。
2.init进程接收到这个属性值改变事件之后，就会调用函数handle_property_set_fd来进行相应的处理。

# activity窗口切换动画

一个窗口属于一个Activity组件窗口，那么当该Activity组件被切换的时候，就会被设置一个切换动画，这是通过调用WindowManagerService类的成员函数setTokenVisibilityLocked来实现的

```java
public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
    boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp,
            boolean visible, int transit, boolean performLayout) {
        boolean delayed = false;
                ......
                applyAnimationLocked(wtoken, lp, transit, visible);
                ......
        return delayed;
    }
    ......
}
```

# 查看activity启动时间

1\. logcat \| grep Displayed
2\. am start -S -W 包名/activity名 如：am start -S -W com.company.wyman.dvbplayer/.MainActivity

# 解决黑白屏问题

app启动流程
![image28-20251225151645-3cjsl2x.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173133689.png)
1.治标：设置背景 themes.xml \<item name=”android:WindowBackground”\>#ff00ee00#\</item\>
2.治本：把耗时操作放到onWindowFocusChanged中，重写onWindowFocusChanged

```java
@Override
public void onWindowFocusChanged(boolean hasFocus) {
super.onWindowFocusChanged(hasFocus);
//to do 耗时操作
}
```

# 查看APP方法耗时时间

## 1.如果API\>=26

勾选Start this，选择Trace Java Methods 通过Profiling进行调试查看
![image29-20251225151645-f408074.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173244982.png)

## 2.如果API\<26

1.首先MyApplication构造方法中调用Debug.startMethodTracing(); lujing为保存的路径通常为sdcard

```java
public class MyApplication extends Application {

    public MyApplication() {
        Debug.startMethodTracing("lujing");
    }

    @Override
    public void onCreate() {
        super.onCreate();
    }
}
```

2.然后在MainActivity中onWindowFocusChanged方法中调用Debug.stopMethodTracing();就可以得到从MyApplication到onWindowFocusChanged方法执行完所消耗的时间（期间包含了MainActivity的oncreate和onresume）

```java
public class MainActivity extends AppCompatActivity {
	。。。
    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        //to do 耗时操作
        Debug.stopMethodTracing();
    }
}
```

## 3.StrictMode模式的使用

![image30-20251225151645-srw6q89.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173309739.png)

# 多渠道打包ProductFlavor

![image31-20251225151645-6bav9s0.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173412191.png)

```java
多渠道打包方式一
android {
    flavorDimensions "versionCode" 
    productFlavors {
        //应用宝、360手机助手、魅族应用市场、华为应用市场、自动更新
        yingyongbao {
            manifestPlaceholders = [CHANNEL_VALUE: "应用宝"]
        }
        qh360 {
            manifestPlaceholders = [CHANNEL_VALUE: "360手机助手"]
        }
        meizu {
            manifestPlaceholders = [CHANNEL_VALUE: "魅族应用市场"]
        }
        huawei {
            manifestPlaceholders = [CHANNEL_VALUE: "华为应用市场"]
        }
        autoUpdate {
            manifestPlaceholders = [CHANNEL_VALUE: "应用内更新"]
        }
    }
}
```

# Context作用

![image32-20251225151645-zs15oh9.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173445361.png)

# 桌面应用启动流程

![image33-20251225151645-mxr5wm8.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173505524.png)

# 查看gpu性能图

debug.hwui.profile=visual_lines
--\>4.4
debug.hwui.profile=visual_bars
--\>5.1

# 查看monkey测试命令

```
monkey -s 1000 --ignore-crashes --ignore-timeouts --ignore-security-exceptions --ignore-native-crashes --kill-process-after-error --pct-touch 30 --pct-motion 0 --pct-trackball 10 --pct-rotation 0 --pct-syskeys 0 --pct-nav 0 --pct-majornav 0 --pct-appswitch 15 --pct-flip 0 --pct-anyevent 45 --pct-pinchzoom 0 -v -v -v --throttle 1000 1200000000 2\>&1 \| busybox tee /sdcard/monkey.log
```

# 查看signal信号设置系统prop属性运行脚本抓取meminfo信息

## 1.signal信号捕获处理流程

[Android4.4.2](http://192.168.105.5:8080/source/xref/version/Android4.4.2/)/[system](http://192.168.105.5:8080/source/xref/version/Android4.4.2/system/)/[core](http://192.168.105.5:8080/source/xref/version/Android4.4.2/system/core/)/[init](http://192.168.105.5:8080/source/xref/version/Android4.4.2/system/core/init/)/[property_service.c](http://192.168.105.5:8080/source/xref/version/Android4.4.2/system/core/init/property_service.c)

```c
void start_property_service(void){
       。。。
    debug_signal_init();
}
void debug_signal_handler(int num) {
    ERROR("debug_signal_handler %d\n",num);
    property_set("goke.debug_signal", "1");
}
void debug_signal_init() {
    char tmp[PROP_VALUE_MAX] = {0};
    if ((property_get("goke.debug_signal.enable", tmp) != 0) && (strcmp(tmp, "true") == 0)) {
        ERROR("debug_signal_init\n");
        struct sigaction action;
        memset(&action, 0, sizeof(action));
        sigemptyset(&action.sa_mask);
        action.sa_sigaction = debug_signal_handler;
        action.sa_flags = SA_SIGINFO;
        sigaction(SIGWINCH, &action, NULL);
    }
}
```

## 2.sh脚本系统运行设置

[Android4.4.2](http://192.168.105.5:8080/source/xref/version/Android4.4.2/)/[device](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/)/[company](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/)/[project](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/project/)/[etc](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/project/etc/)/[init.project.rc](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/project/etc/init.project.rc)

```bash
service goke_debug /system/bin/goke_debug.sh
    class core
    user  root
    group root
    disabled
    oneshot

on property:goke.debug_signal=1
    start goke_debug

on property:goke.debug_signal=0
    stop goke_debug
```

## 3.抓取meminfo脚本内容

[Android4.4.2](http://192.168.105.5:8080/source/xref/version/Android4.4.2/)/[device](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/)/[company](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/)/[project](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/project/)/[etc](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/project/etc/)/[company_debug.sh](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/project/etc/company_debug.sh)

```sh
#!/system/bin/sh

goke_debug=/data/tombstones
goke_meminfo=/data/tombstones/meminfo.txt

#如果目录不存在则创建目录
if [ ! -d $goke_debug ]; then
    echo "\ndo_goke_debug mkdir $goke_debug\n" > /dev/kmsg
    echo "\ndo_goke_debug mkdir $goke_debug\n"
    mkdir $goke_debug
    chown system:system $goke_debug
    chmod 777 $goke_debug
fi

current_time=`date  +%Y%m%d-%H%M%S`

#while [ `getprop goke.cpu.dvfs.scaling` == "benchmark" ]
count=0
total=0
while [ "$total" != 360 ]
do
    date  +%Y%m%d-%H%M%S >> $goke_meminfo
    cat /proc/meminfo >> $goke_meminfo
    cat /proc/buddyinfo >> $goke_meminfo
    cat /proc/vmallocinfo >> $goke_meminfo
    cat /proc/slabinfo >> $goke_meminfo
    cat /proc/pagetypeinfo >> $goke_meminfo
    procrank >> $goke_meminfo
    dumpsys meminfo >> $goke_meminfo
    ps -t >> $goke_meminfo
    if [ "$count" == 3 ]; then
        #echo "\ndo_goke_debug mkdir $count\n"
        date  +%Y%m%d-%H%M%S >> $goke_meminfo
        dumpsys meminfo -a >> $goke_meminfo
        count=0
    else
        #echo "\ndo_goke_debug mkdir $count\n"
        count=$(($count + 1))
    fi
    total=$(($total + 1))
    sleep 5
done
```

## 4.系统编译打包脚本到对应的目录

[Android4.4.2](http://192.168.105.5:8080/source/xref/version/Android4.4.2/)/[device](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/)/[company](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/)/[versionA](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/versionA/)/[device-company.mk](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/versionA/device-company.mk)

```
PRODUCT_COPY_FILES += \\
\$(GK_ETC_DIR)/company_debug.sh:system/bin/company_debug.sh
```

# 查看so库链接到其他库方法

Readelf -a \| grep NEEDED

# 查看Android串口自动化信息抓取脚本

while \[ 1 \] ; do date;dumpsys meminfo -a;cat /proc/vmallocinfo;cat /sys/kernel/debug/ion/heaps/\*;sleep 4;done \>\> /mnt/sda/sda1/lsof.log &

# 调整zram交换空间办法

```
1.#关闭zram
swapoff /dev/block/zram0
2.# 打开zram设置
echo 1 \> /sys/block/zram0/reset
3.# 设置zram=200m
echo 209715200 \> /sys/block/zram0/disksize
4.#写入zram区域
mkswap /dev/block/zram0
5.# 打开zram
swapon /dev/block/zram0
```

# 调整kernel内核low水线

echo 48600 \>/proc/sys/vm/extra_free_kbytes

# 查看zram调用活跃度命令

echo 90 \>/proc/sys/vm/swappiness
参考链接：
[zRAM内存压缩技术原理与应用 (wowotech.net)](http://www.wowotech.net/memory_management/zram.html)
[Linux内存调节之zone watermark - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/73539328)

# 查看使用Android Studio Memory Profiler分析内存泄漏

![image34-20251225151645-8wqx2eg.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173824492.png)
此demo展示了匿名内部类持有外部类没有及时销毁造成的内存泄漏。
参考链接：
[(69条消息) Android性能优化：使用Profiler进行内存优化_cvKnight的博客-CSDN博客_android profiler内存](https://blog.csdn.net/qq_23049111/article/details/121807729)

# 查看GC的类型

GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。
GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操 作来释放内存。
GC_EXPLICIT: 表示是应用程序调用System.gc、VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。
GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。

> 实际上，GC_FOR_MALLOC、GC_CONCURRENT和GC_BEFORE_OOM三种类型的GC都是在分配对象的过程触发的。而并发和非并发GC的区别主要在于前者在GC过程中，有条件地挂起和唤醒非GC线程，而后者在执行GC的过程中，一直都是挂起非GC线程的。并行GC通过有条件地挂起和唤醒非GC线程，就可以使得应用程序获得更好的响应性。但是同时并行GC需要多执行一次标记根集对象以及递归标记那些在GC过程被访问了的对象的操作，所以也需要花费更多的CPU资源。后文在Art的并发和非并发GC中我们也会着重说明下这两者的区别。
> **GC日志中有以下几种类型：**
> GC_FOR_MALLOC: 这是由于Concurrent GC没有及时执行完，而应用又需要分配更多的内存，这时不得不停下来进行Malloc GC。
> GC_CONCURRENT: 当应用程序中的Heap内存占用上升时（分配对象大小超过384k），避免Heap内存满了而触发的GC。如果发现有大量的GC_CONCURRENT出现，说明应用中可能一直有大于384k的对象被分配，而这一般都是一些临时对象被反复创建，可能是对象复用不够所导致的。
> GC_EXTERNAL_ALLOC: 这是为external分配的内存执行的GC。
> GC_HPROF_DUMP_HEAP: 创建一个HPROF profile的时候执行。
> GC_EXPLICIT: 显示调用了System.GC()。（尽量避免）

# 查看Lowmemorykiller水线

1\. /sys/module/lowmemorykiller/parameters/minfree 水线大小，五个等级
2\. /sys/module/lowmemorykiller/parameters/adj adj大小，五个等级
说明：minfree与adj一一对应，当达到minfree水线时就会kill对应adj的进程。
echo 2 \>/sys/module/lowmemorykiller/parameters/debug_level 可以打开swap调用的lmk的大部分打印
![image35-20251225151645-3wpy78g.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225173921657.png)

# 查看踩内存检测工具

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdint.h>
#include <time.h>
/*
pid = 4055, virtual addr = b252c000 , physical addr = 3daf0000
*/
//计算虚拟地址对应的地址，传入虚拟地址vaddr，通过paddr传出物理地址
void mem_addr(unsigned long vaddr, unsigned long *paddr){
    int pageSize = getpagesize();//调用此函数获取系统设定的页面大小
    unsigned long v_pageIndex = vaddr / pageSize;//计算此虚拟地址相对于0x0的经过的页面数
    unsigned long v_offset = v_pageIndex * sizeof(uint64_t);//计算在/proc/pid/page_map文件中的偏移量
    unsigned long page_offset = vaddr % pageSize;//计算虚拟地址在页面中的偏移量
    uint64_t item = 0;//存储对应项的值
    int fd = open("/proc/self/pagemap", O_RDONLY);//以只读方式打开/proc/pid/page_map
    if(fd == -1){//判断是否打开失败
        printf("Open /proc/self/pagemap Failed !!!\n");
        return;
    }
    if(lseek(fd, v_offset, SEEK_SET) == -1){//将游标移动到相应位置，即对应项的起始地址且判断是否移动失败
        printf("Sleek /proc/self/pagemap Failed !!!\n");
        return;
    }
    if(read(fd, &item, sizeof(uint64_t)) != sizeof(uint64_t)){//读取对应项的值，并存入item中，且判断读取数据位数是否正确
        printf("Read item Failed !!!\n");
        return;
    }
    if((((uint64_t)1 << 63) & item) == 0){//判断present是否为0
        printf("Page Present Is 0 Failed !!!\n");
        return ;
    }
    uint64_t phy_pageIndex = (((uint64_t)1 << 55) - 1) & item;//计算物理页号，即取item的bit0-54
    *paddr = (phy_pageIndex * pageSize) + page_offset;//再加上页内偏移量就得到了物理地址
}
int main(){
    char *pbuff;
    int cnt = 0;
    int index = 0;
    int flag = 0;
    int size = 0x100000 * 50;
    time_t timer;
    struct tm *tblock;
    
    pbuff = (char *) malloc(size);
    if (NULL == pbuff){
        printf("Malloc Failed !!!\n");
        return 0;
    }
    memset(pbuff, 0xaa, size);
    unsigned long phy = 0;//物理地址
    //mem_addr((unsigned long)&(pbuff[5]), &phy);
    //printf("Pid[%d] virtualAddr[%x] physicalAddr[%x]\n", getpid(), &(pbuff[5]), phy);
    printf("Pid[%d] Begin Running !!!\n", getpid());
    fflush(stdout);
    while(1){
        index++;
        for(cnt = 0; cnt < size; cnt++){
            if(pbuff[cnt] != 0xaa){
                time(&timer);
                tblock = gmtime(&timer);
                printf("[%d-%d-%d_%2d:%2d:%2d] Check Index[%d] ArrIndex[%d] Date Have Changed to[%2x] Mem Error !!!\n",
                    (tblock->tm_year+1900), (tblock->tm_mon+1), tblock->tm_mday, (tblock->tm_hour+8), tblock->tm_min,
                    tblock->tm_sec, index, cnt, pbuff[cnt]);
                fflush(stdout);
                mem_addr((unsigned long)&(pbuff[cnt]), &phy);
                printf("Pid[%d] virtualAddr[%x] physicalAddr[%x]\n", getpid(), &(pbuff[cnt]), phy);
                fflush(stdout);
                //memset(pbuff, 0xaa, size);
                pbuff[cnt] = 0xaa;
                flag = 1;
            }
        }
        if(!flag){
            time(&timer);
            tblock = gmtime(&timer);
            printf("[%d-%d-%d_%2d:%2d:%2d] Check Index[%d] Success !!!\n", (tblock->tm_year+1900), (tblock->tm_mon+1),
                tblock->tm_mday, (tblock->tm_hour+8), tblock->tm_min, tblock->tm_sec, index);
            fflush(stdout);
            flag = 0;
        }
        usleep(1000000);
    }
}
```

原理就是：malloc 50m内存，memset 0xAA，然后一直循环check 这50m内存是否被改变，如果被改变就打印Mem Error，然后打印出被改变的物理地址，让kernel查，此时哪个ip有踩到此物理地址的嫌疑~
如果gc挂掉怀疑踩内存，也可以在gc 回收object的时候，嵌入转物理地址代码，打印出此异常object对应的物理地址，让kernel 进场一起分析排查

# 查看图片硬件相关

cat  /sys/kernel/debug/ion/heaps/misc 查看图片硬解使用情况
setprop company.hwdec.png 0;setprop company.hwdec.jpeg 0 硬解关掉：每次开机手动设置
cat /proc/ssp/mma 查看视频图形相关信息

# 查看CPU相关

cat /proc/company_dvfs/frequency 查看几核工作
cat /proc/company_dvfs/voltage_core 查看核心电压
echo '0' \>/sys/module/mali/parameters/dvfs_enable 关闭GPU动态电压
echo 0 1568 \>/proc/company_dvfs/frequency 写入cpu频率1568MH

# LMK保活机制

## 1. app_oom_adj_config.json配置

device/company/project/etc/app_oom_adj_config.json

```
{
"version":"20200316",
"map":\[
{"processName":"com.ixia.ixchariot", "adj":-1},
{"processName":"com.gitvdemo.video", "adj":15},
{"processName":"tv.icntv.migu", "adj":15},
{"processName":"com.ktcp.video", "adj":15},
{"processName":"com.dangbeimarket", "adj":15},
{"processName":"com.dbappstore.lite", "adj":15}
\]
}
```

## 2.编译打包脚本到对应的目录

[Android4.4.2](http://192.168.105.5:8080/source/xref/version/Android4.4.2/)/[device](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/)/[company](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/)/[versionA](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/versionA/)/[device-company.mk](http://192.168.105.5:8080/source/xref/version/Android4.4.2/device/company/versionA/device-company.mk)

```
PRODUCT_COPY_FILES += \\
device/company/project/etc/app_oom_adj_config.json:system/etc/app_oom_adj_config.json
```

## 3.在ActivityManagerService.java中实现

```java
//PATCH_6323 s
final static String app_config_oom_adj_path = "/system/etc/app_oom_adj_config.json";
class ConfigApp {
    String processName;
    int adj;
    int lastCalcAdj;
    int iCalcCount;
}

    HashMap<String, ConfigApp> mConfigAppMap = new HashMap<String, ConfigApp>();

    void initAppConfigOomAdj(){
        try {
            String jsonData = getData(new File(app_config_oom_adj_path));

            if (jsonData == null || "".equals(jsonData)){
                Slog.e(TAG, "initAppConfigOomAdj not found " + app_config_oom_adj_path + " !");
                return;
            }
            Slog.i(TAG, "initAppConfigOomAdj jsonData=" + jsonData);
            JSONObject json = new JSONObject(jsonData);
            String version = null;
            if (json.has("version")){
                version = json.getString("version");
            }
            Slog.i(TAG, "initAppConfigOomAdj version=<" + version + ">");
            if (json.has("map")){
                JSONArray array = json.getJSONArray("map");
                for(int i=0; i < array.length(); i++){
                    JSONObject capp = array.getJSONObject(i);
                    if (capp.has("processName")){
                        ConfigApp configApp = new ConfigApp();
                        configApp.processName = capp.getString("processName");
                        configApp.adj = capp.getInt("adj");
                        Slog.i(TAG, "initAppConfigOomAdj package=<" + configApp.processName + "," +  configApp.adj  + ">");
                        mConfigAppMap.put(configApp.processName, configApp);
                    }
                }
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public synchronized static String getData(File file){
        String jsonData = "";
        Slog.i(TAG, "getData s file=" + file);
        InputStreamReader isr = null;
        BufferedReader br = null;
        try {
            int count = 0;
            if (file != null && file.isFile() && file.exists()) {
                try {
                    isr = new InputStreamReader(
                            new FileInputStream(file));
                    br = new BufferedReader(isr);
                    String line = null;
                    while ((line = br.readLine()) != null) {
                        count++;
                        Slog.i(TAG, "getData count=" + count + ", " + line);
                        jsonData += line;
                    }
                } finally {
                    if (isr != null)
                        isr.close();
                    if (br != null)
                        br.close();
                }
            } else {
                Slog.e(TAG, "getData fail, file="
                        + file + " is not exists");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Slog.i(TAG, "getData e");
        return jsonData;
    }
    //PATCH_6323 e

    private ActivityManagerService() {
        //PATCH_6323 s
        initAppConfigOomAdj();
        //PATCH_6323 e
     。。。
    }

    private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP,
                                          boolean doingAll, long now) {
            。。。
        //PATCH_6323 s
        if (app != TOP_APP){
            ConfigApp capp = mConfigAppMap.get(app.processName);
            if (capp != null){
                if (capp.lastCalcAdj != app.curAdj){
                    capp.iCalcCount = 0;
                    capp.lastCalcAdj = app.curAdj;
                } else {
                    if (capp.iCalcCount < 2){
                        capp.iCalcCount ++;
                    }
                }
                if (capp.iCalcCount < 2){//only show 2 times
                    Slog.v(
                            TAG, "computeOomAdjLocked pid=" + app.pid + " " + app.processName +
                                    " <curRawAdj, curAdj> old<" + app.curRawAdj + ", " + app.curAdj + ">"
                                    + " new<" + capp.adj + ", " + app.modifyRawOomAdj(capp.adj) + "> "
                                    + ": " + app.adjType + ", iCalcCount=" + capp.iCalcCount );
                }
                app.curRawAdj = capp.adj;
                app.curAdj = app.modifyRawOomAdj(capp.adj);
                return app.curRawAdj;
            }
        }
        //PATCH_6323 e
        return app.curRawAdj;
    }
```

# 查看excel列转固定行

=OFFSET(\$A\$1,(ROW()-1)\*16+COLUMN()-2,)

# 查看logcat压缩命令

logcat -c;logcat -r200000 -n 2000 -z -v threadtime -f /mnt/sda/sda1/log.log &

# 查看Android打印堆栈轨迹

## 1. C/C++,Jni中 堆栈轨迹

```cpp
#include <utils/CallStack.h>
Void function(){
…
    android::CallStack cs("qinlog");
}

android::CallStack stack;
stack.update();
const char* str = stack.toString();
ALOGI(“ str=%s”,str);

LOCAL_SHARED_LIBRARIES :=\
	libutilscallstack
```

![image40-20251225151645-6z008vy.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225174334488.png)

## 2. Java中打印堆栈轨迹

Thread.dumpStack();

# 查看Android编译打开调试选项

LOCAL_CFLAGS += -g -O0
LOCAL_CFLAGS参数说明
1、-Wall 是打开警告开关
2、-O 代表默认优化，可选：-O0不优化，-O1低级优化，-O2中级优化，-O3高级优化，-Os代码空间优化
3、-g 是生成调试信息，生成的可执行文件具有和源代码关联的可调试的信息

# 查看在任意类中，获取pid与进程信息

```java
int mypid = android.os.Process.myPid();
int num=0;
try{
    IActivityManager am = IActivityManager.Stub.asInterface(ServiceManager.getService(Context.ACTIVITY_SERVICE));
    List<RunningAppProcessInfo> ProcessList = am.getRunningAppProcesses();
    if(ProcessList!=null&&ProcessList.size()>0){
        for(ActivityManager.RunningAppProcessInfo appProcess:ProcessList){
            if(appProcess.pid==myPid&&"com.android.settings".equals(appProcess.ProcessName)){
                num=1;
                break;
            }
        }
    }
} catch (Exception e){
    e.printStackTrace();
}
```

# 查看JVM线程状态

## 一、线程在[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)中的6种状态

**NEW**
A thread that has not yet started is in this state. 没有开始执行的线程处于这种状态
**RUNNABLE**
A thread executing in the Java virtual machine is in this state. 在JVM中执行的线程处于这种状态
**BLOCKED**
A thread that is blocked waiting for a monitor lock is in this state.
因为等待监视器锁而处于等待的线程处于这种状态
**WAITING**
A thread that is waiting indefinitely for another thread to perform a particular action is in this state. 等待另一个线程执行某些特别操作的线程处于这种状态。补充：实际上，这个线程等待的条件称为条件谓词，这个线程等待的位置称为条件队列。来源大牛的书《Java Concurrency in Proactice》
**TIMED_WAITING**
A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state. 等待另一个线程执行某些特别操作的线程（有时间限制）处于这种状态
**TERMINATED**
A thread that has exited is in this state. 一个已经执行完毕的线程处于这种状态。

## 二、线程在JVM中的状态转换

![image41-20251225151645-upvij6q.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225174548816.png)

## 三、线程在Java Thread 的状态与C++ 层Thread 状态区别

| **java Thread 的状态** | **C++ 层Thread 状态** | **说明**                         |
| ---------------------- | --------------------- | -------------------------------- |
| NEW                    | INITIALIZING          | 新建，正在分配资源               |
| NEW                    | STARING               | 新建，正在启动                   |
| RUNNABLE               | RUNING/RUNNABLE       | 线程创建或者正在运行             |
| RUNNABLE               | NATIVE                | 正在执行 JNI 方法                |
| RUNNABLE               | SUSPENDED             | 现在挂起，一般是GC导致           |
| BLOCKED                | MOINITOR              | 线程阻塞，等待其它线程释放对象锁 |
| WAITING                | WAIT                  | 执行了无超时参数的 wait() 等方法 |
| WAITING                | VMWAIT                | 正在等待 VM 资源                 |
| TERMINATED             | ZOMBIE                | 线程销毁                         |

[Android线程状态 - 简书 (jianshu.com)](https://www.jianshu.com/p/c389dcdb5a4b)

# 查看linux测硬盘读写速度、内存读写速度

## 1.测硬盘读写速度可以用以下命令：

dd if=/dev/zero of=file bs=1M count=1024

## 2.测内存读写速度可以用以下命令：

dd if=/dev/zero of=/dev/null bs=1M count=1024

# framework配置文件编译覆盖

如：[frameworks](http://192.168.143.187:8080/source/xref/version/frameworks/)/[base](http://192.168.143.187:8080/source/xref/version/frameworks/base/)/[core](http://192.168.143.187:8080/source/xref/version/frameworks/base/core/)/[res](http://192.168.143.187:8080/source/xref/version/frameworks/base/core/res/)/[res](http://192.168.143.187:8080/source/xref/version/frameworks/base/core/res/res/)/[values](http://192.168.143.187:8080/source/xref/version/frameworks/base/core/res/res/values/)/[config.xml](http://192.168.143.187:8080/source/xref/version/frameworks/base/core/res/res/values/config.xml)
窗体顶端
可在vendor/device/aosp/tv/overlay/frameworkResOverlay/res/values/config.xml如下路径添加item进行覆盖
然后在frameworkResOv erlay编译生成apk覆盖

# 查看lmkd相关信息解读

## 1.lmkd水线与ADJ设置

\[sys.lmk.minfree_levels\]: \[18432:0,23040:100,27648:200,32256:250,55296:900,80640:950\]
minfree:adj 6档水线设置，注意：minfree(单位:page), minfree \* 4 = 真实值KB

### adj值定义：

```java
ProcessList.java 
private final int[] mOomAdj = new int[] {
              FOREGROUND_APP_ADJ, VISIBLE_APP_ADJ, PERCEPTIBLE_APP_ADJ,
              PERCEPTIBLE_LOW_APP_ADJ, CACHED_APP_MIN_ADJ, CACHED_APP_LMK_FIRST_ADJ
      };
```

### minfree值定义：(单位:KB)

```java
private final int[] mOomMinFreeLow = new int[] {
             12288, 18432, 24576,
             36864, 43008, 49152
};
private final int[] mOomMinFreeHigh = new int[] {
        73728, 92160, 110592,
        129024, 147456, 184320
};
```

可以看到这里有两套minfree水线值，具体使用mOomMinFreeLow还是mOomMinFreeHigh，还需要经过一系列算法换算后，才是真正sys.lmk.minfree_levels填充值。

### minfree值核心算法：

```java
ProcessList.java 
private void updateOomLevels(int displayWidth, int displayHeight, boolean write) {
    ...
    float scaleMem = ((float) (mTotalMemMb - 350)) / (700 - 350);
    int minSize = 480 * 800;  // 384000
    int maxSize = 1280 * 800; // 1024000
    float scaleDisp = ((float)(displayWidth * displayHeight) - minSize) / (maxSize - minSize);
    float scale = scaleMem > scaleDisp ? scaleMem : scaleDisp;
    if (scale < 0) scale = 0;
    else if (scale > 1) scale = 1;
    for (int i = 0; i < mOomAdj.length; i++) {
        int low = mOomMinFreeLow[i];
        int high = mOomMinFreeHigh[i];
        if (is64bit) {
            // Increase the high min-free levels for cached processes for 64-bit
            if (i == 4) high = (high * 3) / 2;
            else if (i == 5) high = (high * 7) / 4;
        }
        mOomMinFree[i] = (int)(low + ((high - low) * scale));
}}
```

上面算法最终决定用low还是high，其实与scale参数有关，scale的计算受总内存大小与屏幕分辨率影响；我们可以看到scaleMem与scaleDisp的计算，只要总内存\>700M,屏幕分辨率\>1280\*800,无论scale取决与谁，都\>1;所以，最终mOomMinFree= mOomMinFreeHigh的值，值得注意的是，对于64位系统，mOomMinFree[4]与mOomMinFree[5]会被适当放大3/2与7/4倍。

## 2.LMKD查杀机制

```java
lowmemorykiller: Kill 'com.android.keychain' (4082), uid 1000, oom_score_adj 995 to free 86188kB rss, 0kb swap
lowmemorykiller: Reclaimed 86188kB, cache(295796kB) and free(13416kB)-reserved(16528kB) below min(322560kB) for oom_score_adj 950
```

上面是lmkd的查杀日志，可以看到当空闲内存cache+free-reserved[min(322560KB=80640*4)时，触发了sys.lmk.minfree_levels的第6档水线[80640:950],且com.android.keychain应用adj=995](min(322560KB=80640*4)%E6%97%B6%EF%BC%8C%E8%A7%A6%E5%8F%91%E4%BA%86sys.lmk.minfree_levels%E7%9A%84%E7%AC%AC6%E6%A1%A3%E6%B0%B4%E7%BA%BF%5B80640:950%5D,%E4%B8%94com.android.keychain%E5%BA%94%E7%94%A8adj=995)950,所以被查杀。cache与free可以通过cat /proc/meminfo查看，这里的关键是reserved的计算。
![image42-20251225151645-0399qnb.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225174801969.png)
原始日志定义，可以看到这里的reserved是zi->totalreserve_pages，所以接下来看一下zi->totalreserve_pages的计算规则。

### reserved计算

```cpp
static int zoneinfo_parse(struct zoneinfo *zi) {
...
for (node_idx = 0; node_idx < zi->node_count; node_idx++) {
    node = &zi->nodes[node_idx];
    for (zone_idx = 0; zone_idx < node->zone_count; zone_idx++) {
        struct zoneinfo_zone *zone = &zi->nodes[node_idx].zones[zone_idx];
        zi->totalreserve_pages += zone->max_protection + zone->fields.field.high;
    }
    ...
}}
```

上面的算法是通过cat /proc/zoneinfo节点遍历node，zone，及zone里面具体的参数zone->max_protection与zone->fields.field.high累计得到的 zi->totalreserve_pages。
要理解遍历zoneinfo里面的这些节点信息，需要了解linux内存管理，简单来说linux物理内存由node，zone，page三级结构来描述的，而node是根据当前的系统是NUMA还是UMA系统。假设我们当前是UMA系统架构，则只有一个node，如下图所示：
![image43-20251225151645-hauzgfl.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225174935400.png)
详情见：[物理内存管理之zone详解](https://cloud.tencent.com/developer/article/1613342)
调整sys.sysctl.extra_free_kbytes=2048KB，此属性与/proc/sys/vm/extra_free_kbytes有关，此节点预设值，将会增加watermark中min与low，high之间的水线；而上面lowmemorykiller中reserved=zone.high+zone.protection,所以减小extra_free_kbytes，会降低reserved保留内存，减少lmk触发水线

# 内存信息解读

## 系统cat /proc/meminfo内存信息解读

```bash
MemTotal:        1852372 kB     // 可供系统支配的内存 （即物理内存减去一些预留位和内核的二进制代码大小）
MemFree:           37696 kB     // LowFree与HighFree的总和，系统中未使用的内存
MemAvailable:     450336 kB     //应用程序可用内存，MemAvailable≈MemFree+Buffers+Cached，它与MemFree的关键区别点在于，MemFree是说
                           的系统层面，MemAvailable是说的应用程序层面
Buffers:             6396 kB     // 缓冲区内存数，对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大 （20MB 左右）
Cached:           356188 kB     // 缓存区内存数
SwapCached:         7276 kB     // 交换文件中的已经被交换出来的内存。与 I/O 相关
Active:           311292 kB     // 经常（最近）被使用的内存
Inactive:         480008 kB      // 最近不常使用的内存。这很容易被系统移做他用
Active(anon):     171276 kB     // 活跃的匿名内存（进程中堆上分配的内存,是用malloc分配的内存）
Inactive(anon):   265492 kB      // 不活跃的匿名内存
Active(file):     140016 kB      // 活跃的与文件关联的内存（比如程序文件、数据文件所对应的内存页） 
Inactive(file):   214516 kB       // 不活跃的与文件关联的内存
Unevictable:        4588 kB     // 不能被释放的内存页
Mlocked:            4588 kB     // mlock()系统调用锁定的内存大小
SwapTotal:       1048572 kB     // 交换空间总大小
SwapFree:         761596 kB     // 空闲的交换空间大小
Dirty:               160 kB     // 等待被写回到磁盘的大小
Writeback:             0 kB     // 正在被写回的大小
AnonPages:        427180 kB     // 未映射页的大小
Mapped:           173744 kB     // 设备和文件映射大小
Shmem:              5240 kB     // 已经被分配的共享内存大小
KReclaimable:      86568 kB      // SReclaimable
Slab:             222916 kB     // 内核数据结构缓存大小
SReclaimable:      53184 kB     // 可收回Slab的大小
SUnreclaim:       169732 kB     // 不可收回的Slab的大小
KernelStack:       24256 kB      // kernel消耗的内存
PageTables:        51660 kB     // 管理内存分页的索引表的大小
NFS_Unstable:          0 kB     // 不稳定页表的大小
Bounce:                0 kB     // 在低端内存中分配一个临时buffer作为跳转，把位于高端内存的缓存数据复制到此处消耗的内存
WritebackTmp:          0 kB     // 用于临时写回缓冲区的内存
CommitLimit:     1974756 kB     // 系统实际可分配内存总量
Committed_AS:   57596844 kB     // 当前已分配的内存总量
VmallocTotal:   262930368 kB     // 虚拟内存大小
VmallocUsed:       60084 kB     // 已经被使用的虚拟内存大小
VmallocChunk:          0 kB     // 在 vmalloc 区域中可用的最大的连续内存块的大小
Percpu:             7360 kB
CmaTotal:          53248 kB     // 连续可用内存总数
CmaFree:               0 kB     // 空闲的连续可用内存
```

meminfo详解 - sudochen - 博客园 (cnblogs.com)

## 系统dumpsys meminfo 内存信息解读

```
Total RAM: 1,852,372K (status low)
Free RAM: 225,168K ( 29,792K cached pss + 74,832K cached kernel + 120,544K free)
ION: 447,928K ( 203,480K mapped + 240,396K unmapped + 4,052K pools)
Used RAM: 1,698,916K (1,266,388K used pss + 432,528K kernel)
Lost RAM: 91,966K
ZRAM: 66,260K physical used for 237,312K in swap (1,048,572K total swap)
Tuning: 256 (large 768), oom 107,520K, restore limit 35,840K (high-end-gfx)
```

**Total RAM**
就是/proc/meminfo 中的 MemTotal
**Free RAM**
cached pss：all pss of process oom_score_adj \>= 900
cached kernel：/proc/meminfo.Buffers+/proc/meminfo.Kreclaimable+/proc/meminfo.Cached-
/proc/meminfo.Mapped ≥Android11
cached kernel：/proc/meminfo.Buffers+/proc/meminfo.SReclaimable +/proc/meminfo.Cached-
/proc/meminfo.Mapped ＜Android11
free：/proc/meminfo.MemFree
**ION**
ion heap size：读取 /sys/kernel/ion/total_heaps_kb
ion pool size：读取 /sys/kernel/ion/total_pools_kb
ion mapped + ion unmapped = ion heap
**Used RAM**
used pss：totalPss - cachedPss

> KernelUsed：/proc/meminfo.Shmem + /proc/meminfo.SlabUnreclaim + VmallocUsed +
> /proc/meminfo.PageTables+/proc/meminfo.KernelStack
> 注意上面的 KernelStack，只要在kernel 没有配置 CONFIG_VMAP_STACK 时，才会加上
> VmallocUsed:是统计/proc/vmallocinfo中除ioremap,map_lowmem,vm_map_ram(versionC： ioremap,map_lowmem,vm_map_ram,vmalloc)之外的和，详细见Debug.get_allocated_vmalloc_memory().
> **Lost RAM**
> proc/meminfo.Memtotal - (totalPss - totalSwapPss) - /proc/meminfo.Memfree
> 
> - cached kernel - KernelUsed - zram used
>   **ZRAM**
>   zram physical size：/sys/block/zram0/mm_stat 第三个参数
>   swap total：proc/meminfo.SwapTotal
>   swap free：proc/meminfo.SwapFree
>   swap used： swap total - swap free
>   **Tuning**
>   large：dalvik.vm.heapsize属性取值，单位为MB
>   oom：ProcessList中mOomMinFree数组最后一个元素取值
>   restore limit：ProcessList中mCachedRestoreLevel变量取值，将一个进程从cached 到
>   background的最大值，一般是mOomMinFree 最后一个值的 1/3.
> 
> low-ram：是否为low ram 设备，一般通过prop ro.config.low_ram，或者当ro.debuggable 使能时prop debug.force_low_ram。
> 
> high-end-gfx：ro.config.low_ram 为false，且ro.config.avoid_gfx_accel 为false，
> 且config config_avoidGfxAccel 的值为false。
> 
> [dumpsys meminfo 详解_私房菜的博客-CSDN博客_dumpsys meminfo](https://blog.csdn.net/shift_wwx/article/details/126269031)
> [Android内存占用分析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/90076117?utm_id=0)

# Android12/13 模块编译

```
make fastboot -j32 out/target/product/tv/obj/EMMC_FIRSTBOOT_OBJ
make sbl -j32 out/target/product/tv/obj/EMMC_SECONDBOOT_OBJ
make slaveboot -j32 out/target/product/tv/obj/EMMC_SLAVEBOOT_OBJ
make dtboimage -j32
make odmimg
make bootimage -j32 out/target/product/tv/obj/KERNEL_OBJ
make superimage -j32 \|tee super.log
make userdataimage -j32 \|tee userdataimage.log
make cacheimage -j32 \|tee cacheimage.log
make recoveryimg -j32
make otapackage -j32
```

# 查看Android系统linux config配置项

**gunzip -c /proc/config.gz**

# 104.设置进程的nice优先级

**busybox renice -n -19  xxx   (将pid为xxx的线程nice值设为-19)**

# 查看CPU线程核调度

**busybox top –H **
![image44-20251225151645-u3ugkgj.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225175113529.png)

# cgroup-v1的配置与使用

## 1. 查看cgroup的挂载点.

```
console:/ \$ mount \| grep cgroup
none on /acct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)
none on /dev/cpuctl type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)
none on /dev/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset,noprefix,release_agent=/sbin/cpuset_release_agent)
cg2_bpf on /dev/cg2_bpf type cgroup2 (rw,nosuid,nodev,noexec,relatime)
console:/ \$
```

## 2. cpuset

> cpuset是一个用来分配限制CPU和Memory资源的CGroup子系统。cpuset使用sched_setaffinity系统调用来设置tasks的CPU亲和性，使用mbind和set_mempolicy包含Memory策略中的Memory Nodes。调度器不会在cpuset之外的CPU上面调度tasks，页分配器也不会在mems_allowed之外的内存中分配。
> cpuset提供了一种灵活配置CPU和Memory资源的机制。Linux中已经有配置CPU资源的cpu子系统和Memory资源的memory子系统

### cpuset配置说明

```
console:/ \# cd /dev/cpuset/
console:/dev/cpuset \# ls -al
drwxr-xr-x 2 system system 0 1970-01-01 08:00 background
-rw-r --r -- 1 root root 0 2023-01-06 16:22 cgroup.clone_children
-rw-r --r -- 1 root root 0 2023-01-06 16:22 cgroup.procs
-r --r --r -- 1 root root 0 2023-01-06 16:22 cgroup.sane_behavior
-rw-r --r -- 1 root root 0 2023-01-06 16:22 cpu_exclusive
-rw-r --r -- 1 root root 0 1970-01-01 08:00 cpus
-r --r --r -- 1 root root 0 2023-01-06 16:22 effective_cpus
-r --r --r -- 1 root root 0 2023-01-06 16:22 effective_mems
drwxr-xr-x 2 system system 0 1970-01-01 08:00 foreground
-rw-r --r -- 1 root root 0 2023-01-06 16:22 mem_exclusive
-rw-r --r -- 1 root root 0 2023-01-06 16:22 mem_hardwall
-rw-r --r -- 1 root root 0 2023-01-06 16:22 memory_migrate
-r --r --r -- 1 root root 0 2023-01-06 16:22 memory_pressure
-rw-r --r -- 1 root root 0 2023-01-06 16:22 memory_pressure_enabled
-rw-r --r -- 1 root root 0 2023-01-06 16:22 memory_spread_page
-rw-r --r -- 1 root root 0 2023-01-06 16:22 memory_spread_slab
-rw-r --r -- 1 root root 0 1970-01-01 08:00 mems
-rw-r --r -- 1 root root 0 2023-01-06 16:22 notify_on_release
-rw-r --r -- 1 root root 0 2023-01-06 16:22 release_agent
drwxr-xr-x 2 system system 0 1970-01-01 08:00 restricted
-rw-r --r -- 1 root root 0 2023-01-06 16:22 sched_load_balance
-rw-r --r -- 1 root root 0 2023-01-06 16:22 sched_relax_domain_level
drwxrwxr-x 2 system system 0 1970-01-01 08:00 system-background
-rw-rw-r -- 1 system system 0 1970-01-01 08:00 tasks
drwxr-xr-x 2 system system 0 1970-01-01 08:00 top-app
```

**background**

> 后台进程cgroup子系统组
> **cgroup.clone_children**
> 仅适用于cpuset。如果使能，创建子cpuset时，就会拷贝父cpust的配置。
> 
> clone_children 是做什么的？
> 
> 此标志仅影响 cpuset 控制器。如果在 cgroup 中启用了 clone_children 标志 (1)，则新的 cpuset cgroup 将在初始化期间从父 cgroup 复制其配置
> **cgroup.procs**
> 属于该分组的PID列表，仅包括多线程进程的线程leader的TID，这点和tasks不同。
> **cgroup.sane_behavior**
> 分层的cgroups
> 
> 节流阀门实现了分层支持。然而分层结构的支持是由cgroup的sane_behavior来使能的，而它是一个开发选项而不是公共可用选项。
> 
> 如果创建这样一个分层结构：
> 
> root
> 
> / \\
> 
> test1 test2
> 
> \|
> 
> test3
> 
> 有"sane_behavior"的节流阀门能正确地处理结构。应用到整个子树（统计本地IO的）的所有的阀门限制直接由该cgroup中的任务生成。
> 
> 没有“sane_behavior”使能的节流阀门几乎把所有分组当作同级对待，它看起来是这样的：
> 
> pivot
> 
> / / \\ \\
> 
> root test1 test2 test3
> **cpu_exclusive**
> spuset.cpu_exclusive 指定其它 cpuset 及其上、下级cgroup是否可共享为这个 cpuset 指定的 CPU 的标签（0 或者 1）。默认情况下（0）CPU 不是专门分配给某个 cpuset 的。
> **cpus**
> cpuset.cpus指定允许这个 cgroup 中任务访问的 CPU。这是一个用逗号分开的列表，格式为 ASCII，使用小横线（"-"）代表范围。如下，代表 CPU 0、1、2 和 16。
> 
> \# cat cpuset.cpus
> 
> 0-2,16
> **effective_cpus**
> cpuset.effective_cpus和cpuset.effective_mems文件分别是cpuset.cpus和cpuset.mems文件的只读副本。如果cpuset文件系统以特定的cpuset_v2_mode选项挂载，这些文件的行为将和cpuset v2版本的相关文件类似。换句话说，热插拔事件不会改变cpuset.cpus和cpuset.mems。这些事件将只影响到cpuset.effective_cpus和cpuset.effective_mems，他们会显示cpuset当前真正在使用的cpu和内存节点。更多的cpuset v2版本的行为请参看Control Group v2版本。
> **effective_mems**
> 同上
> **foreground**
> 前台进程cgroup子系统组
> **mem_exclusive**
> cpuset.mem_exclusive 指定其它 cpuset 是否可共享为这个 cpuset 指定的内存节点的标签（0 或者 1）。默认情况下（0）内存节点不是专门分配给某个 cpuset 的。专门为某个 cpuset 保留内存节点（1）与使用 cpuset.mem_hardwall 启用内存 hardwall 功能是一致的。
> **mem_hardwall**
> cpuset.mem_hardwall指定是否应将内存页面的内核分配限制在为这个 cpuset 指定的内存节点的标签（0 或者 1）。默认情况下为 0，属于多个用户的进程共享页面和缓冲。启用 hardwall 时（1）每个任务的用户分配应保持独立。
> **memory_migrate**
> cpuset.memory_migrate 用来指定当 cpuset.mems 中的值更改时是否应该将内存中的页迁移到新节点的标签（0 或者 1）。默认情况下禁止内存迁移（0）且页就保留在原来分配的节点中，即使在 cpuset.mems 中现已不再指定这个节点。如果启用（1），则该系统会将页迁移到由 cpuset.mems 指定的新参数中的内存节点中，可能的情况下保留其相对位置 - 例如：原来由 cpuset.mems 指定的列表中第二个节点中的页将会重新分配给现在由 cpuset.mems 指定的列表的第二个节点中，如果这个位置是可用的。
> **memory_pressure**
> cpuset.memory_pressure是运行在这个 cpuset 中产生的平均内存压力的只读文件。启用 cpuset.memory_pressure_enabled 时，这个伪文件中的值会自动更新，否则伪文件包含的值为 0。
> **memory_pressure_enabled**
> puset.memory_pressure_enabled指定系统是否应该计算这个 cgroup 中进程所生成内存压力的标签（0 或者 1）。计算出的值会输出到 cpuset.memory_pressure，且代表进程试图释放使用中内存的比例，报告为尝试每秒再生内存的整数值再乘 1000。
> **memory_spread_page**
> cpuset.memory_spread_page指定是否应将文件系统缓冲平均分配给这个 cpuset 的内存节点的标签（0 或者 1）。默认情况为 0，不尝试为这些缓冲平均分配内存页面，且将缓冲放置在运行生成缓冲的进程的同一节点中。
> **memory_spread_slab**
> cpuset.memory_spread_slab指定是否应在 cpuset 间平均分配用于文件输入/输出操作的内核缓存板的标签（0 或者 1）。默认情况是 0，即不尝试平均分配内核缓存板，并将缓存板放在生成这些缓存的进程所运行的同一节点中。
> **mems**
> cpuset.mems指定允许这个 cgroup 中任务可访问的内存节点。这是一个用逗号分开的列表，格式为 ASCII，使用小横线（"-"）代表范围。如下代表内存节点 0、1、2 和 16。
> 
> \# cat cpuset.mems
> 
> 0-2,16
> **notify_on_release**
> 设置是否执行release_agent，为1时使能。
> 
> notify_on_release 是做什么的？
> 
> 如果在 cgroup 中启用了 notify_on_release 标志 (1)，则每当 cgroup 中的最后一个任务离开（退出或附加到其他 cgroup）并且该 cgroup 的最后一个子 cgroup 被删除时，内核运行由指定的命令该层次结构根目录中“release_agent”文件的内容，提供废弃的 cgroup 的路径名（相对于 cgroup 文件系统的挂载点）。这样可以自动删除废弃的 cgroup。系统启动时根 cgroup 中 notify_on_release 的默认值是禁用的 (0)。其他 cgroups 在创建时的默认值是其父母的 notify_on_release 设置的当前值。 cgroup 层次结构的 release_agent 路径的默认值为空。
> **release_agent**
> 删除分组时执行的命令，这个文件只存在于根分组。
> **restricted**
> 受限制的进程cgroup子系统组
> **sched_load_balance**
> cpuset.sched_load_balance指定是否在这个 cpuset 中跨 CPU 平衡负载内核的标签（0 或者 1）。默认情况是 1，即内核将超载 CPU 中的进程移动到负载较低的 CPU 中以便平衡负载。 请注意：如果在任意上级 cgroup 中启用负载平衡，则在 cgroup 中设定这个标签没有任何效果，因为已经在较高一级 cgroup 中处理了负载平衡。因此，要在 cgroup 中禁用负载平衡，还要在该层级的每一个上级 cgroup 中禁用负载平衡。这里您还应该考虑是否应在所有平级 cgroup 中启用负载平衡。
> **sched_relax_domain_level**
> cpuset.sched_relax_domain_level包含 -1 到小正数间的整数，它代表内核应尝试平衡负载的 CPU 宽度范围。如果禁用了 cpuset.sched_load_balance，则该值毫无意义。
> **system-background**
> 系统后台线程cgroup子系统组
> **tasks**
> 属于该分组的线程TID列表。
> **top-app**
> 前台顶层线程Group子系统组

### 创建cpuset 子系统

```
console:/ \# mkdir /dev/cpuset/test
console:/ \# echo 0 \> /dev/cpuset/test/mems
console:/ \# echo 3 \> /dev/cpuset/test/cpus
console:/ \#
```

首先创建了一个 cpuset 子系统叫 test，然后将核心 4 绑到该子系统，即 cpu3。对于 cpuset.mems 参数而言，每个内存节点和 NUMA 节点一一对应。如果进程的内存需求量较大，可以把所有的 NUMA 节点都配置进去。这里就用到了 NUMA 的概念。出于性能的考虑，配置的逻辑核和内存节点一般属于同一个 NUMA 节点，可用 numactl --hardware 命令获知它们的映射关系。很显然，我的主机没有采用 NUMA 架构，只需将其设为节点 0 就好了。

```
console:/dev/cpuset/test \# cat tasks
console:/dev/cpuset/test \#
```

目前 tasks 文件是空的，也就是说，还没有进程运行在该 cpuset 子系统上。需要想办法让指定的进程运行在该子系统上：

### 绑定pid到cpuset子系统

将已经运行的进程的 PID 写入 tasks 文件中，首先运行一个程序：

```
console:/dev/cpuset/test \# /data/test.sh &
\[1\] 5670
console:/dev/cpuset/test \#
然后将 PID 写入 test 目录的 tasks 中：
console:/dev/cpuset/test \# echo 5670 \> tasks
console:/dev/cpuset/test \# cat tasks
5670
console:/dev/cpuset/test \#
```

查看CPU调度情况：
![image45-20251225151645-m0pw184.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225175320942.png)
可以看到绑核生效了，PID 为5670 的进程被调度到了 cpu3 上。

## 3. cpuctl

使用调度程序为CGroup任务提供CPU的访问,进行cpu资源的分配与限制。

### 开启cpu资源限额内核配置项

**CONFIG_CFS_BANDWIDTH=y**
打开此配置项后，在cpuctl节点下会增加cpu.cfs_quota_us，cpu.cfs_period_us: cpu (限额，限制最大负载),两个选项。

### cpuctl配置说明

```
console:/ \# cd /dev/cpuctl/
console:/dev/cpuctl \# ls -al
-rw-r--r -- 1 root root 0 2023-01-06 15:21 cgroup.clone_children
-rw-r--r -- 1 root root 0 2023-01-06 15:21 cgroup.procs
-r --r--r -- 1 root root 0 2023-01-06 15:21 cgroup.sane_behavior
-rw-r--r -- 1 root root 0 2023-01-06 15:21 cpu.cfs_period_us
-rw-r--r -- 1 root root 0 2023-01-06 15:21 cpu.cfs_quota_us
-rw-r--r -- 1 root root 0 1970-01-01 08:00 cpu.rt_period_us
-rw-r--r -- 1 root root 0 1970-01-01 08:00 cpu.rt_runtime_us
-rw-r--r -- 1 root root 0 2023-01-06 15:21 cpu.shares
-r --r--r -- 1 root root 0 2023-01-06 15:21 cpu.stat
-rw-r--r -- 1 root root 0 2023-01-06 15:21 notify_on_release
-rw-r--r -- 1 root root 0 2023-01-06 15:21 release_agent
-rw-rw-rw- 1 system system 0 1970-01-01 08:00 tasks
console:/dev/cpuctl \#
```

**cgroup.clone_children**

> 仅适用于cpuset。如果使能，创建子cpuset时，就会拷贝父cpust的配置。
> 
> clone_children 是做什么的？
> 
> 此标志仅影响 cpuset 控制器。如果在 cgroup 中启用了 clone_children 标志 (1)，则新的 cpuset cgroup 将在初始化期间从父 cgroup 复制其配置
> **cgroup.procs**
> 属于该分组的PID列表，仅包括多线程进程的线程leader的TID，这点和tasks不同。
> **cgroup.sane_behavior**
> 同cpuset参数
> **cpu.cfs_period_us**
> cfs_period_us表示一个cpu带宽，单位为微秒。系统总CPU带宽： cpu核心数 \* cfs_period_us
> **cpu.cfs_quota_us**
> cfs_quota_us表示Cgroup可以使用的cpu的带宽，单位为微秒。cfs_quota_us为-1，表示使用的CPU不受cgroup限制。cfs_quota_us的最小值为1ms(1000)，最大值为1s。
> 
> 结合cfs_period_us,就可以限制进程使用的cpu。例如配置cfs_period_us=10000，而cfs_quota_us=2000。那么该进程cpu使用率最大为20%。
> **cpu.rt_period_us**
> 以微秒（µs，这里以“us”代表）为单位指定在某个时间段中 cgroup 对 CPU 资源访问重新分配的频率。如果某个 cgroup 中的任务应该每 5 秒钟有 4 秒时间可访问 CPU 资源，则请将 cpu.rt_runtime_us 设定为 4000000，并将 cpu.rt_period_us 设定为 5000000。
> 
> 主要是用来设置cgroup中的任务可以最长获得CPU资源的时间，单位为微秒。设定这个值可以访问某个cgroup独占CPU资源。最长的获取CPU资源时间取决于逻辑CPU的数量。比如cpu.rt_runtime_us设置为200000（0.2秒），cpu.rt_period_us设置为1000000（1秒）。在单个逻辑CPU上的获得时间为每秒为0.2秒。 2个逻辑CPU，获得的时间则是0.4秒。
> **cpu.rt_runtime_us**
> 以微秒（µs，这里以“us”代表）为单位指定在某个时间段中 cgroup 中的任务对 CPU 资源的最长连续访问时间。建立这个限制是为了防止一个 cgroup 中的任务独占 CPU 时间。如果 cgroup 中的任务应该可以每 5 秒中可有 4 秒时间访问 CPU 资源，请将 cpu.rt_runtime_us 设定为 4000000，并将 cpu.rt_period_us 设定为 5000000。
> **cpu.shares**
> 通过cfs_period_us和cfs_quota_us可以以绝对比例限制cgroup的cpu使用，即cfs_quota_us/cfs_period_us 等于进程可以利用的cpu cores，不能超过这个数值。
> 
> 而cpu.shares以相对比例限制cgroup的cpu。例如：在两个 cgroup 中都将 cpu.shares 设定为 1 的任务将有相同的 CPU 时间，但在 cgroup 中将 cpu.shares 设定为 2 的任务可使用的 CPU 时间是在 cgroup 中将 cpu.shares 设定为 1 的任务可使用的 CPU 时间的两倍。获得2/(1+2)=66%的cpu使用率。
> **cpu.stat**
> cpuacct.stat记录cgroup的所有任务（包括其子孙层级中的所有任务）使用的用户和系统CPU时间.
> 
> \# cat cpuacct.stat
> 
> user 2030466 \#用户模式中任务使用的CPU时间
> 
> system 623280 \#系统模式(内核)中任务使用的CPU时间
> **notify_on_release**
> 同cpuset参数
> **release_agent**
> 同cpuset参数
> **tasks**
> 属于该分组的线程TID列表。

### 创建cpuctl子系统

```
console:/ \# mkdir /dev/cpuctl/test
console:/ \#
100000
console:/ \# cat /dev/cpuctl/test/cpu.cfs_quota_us
-1
console:/ \# echo 20000 \> /dev/cpuctl/test/cpu.cfs_quota_us
console:/ \#
```

创建了一个 cpuctl子系统叫 test，然后查看cpu带宽最大负载cpu.cfs_period_us=100000，默认cpu.cfs_quota_us=-1表示不受cgroup限制。重新设置cpu.cfs_quota_us=20000，表示限制test子系统内线程最多使用20%cpu。

### 绑定pid到cpuctl子系统

将之前在cpuset时创建的test.sh的PID 写入 test 目录的 tasks 中：

```
console:/dev/cpuctl/test \# echo 5670 \> tasks
console:/dev/cpuctl/test \# cat tasks
5670
console:/dev/cpuctl/test \#
```

查看CPU调度情况：
![image46-20251225151645-vrwgbq1.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225175426929.png)
可以看到限制cpu使用率已经生效了，PID 为5670 的进程被限制在了20%cpu使用率左右。

# android13 查看window窗口状态

cat /proc/msp/winxxx
![image47-20251225151645-ebe5lub.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225175853553.png)
如surfaceview会有单独的window，所有页面顶层dockview会有单独的window，销毁时可以查看handle是否对的上，如上图所示：window 0x5e1f0000被销毁，导致视频窗口黑屏。

# cpu频率与模式设置

设置最大频率
echo 1500000 \> /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
设置最小频率
echo 1200000 \> /sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq
设置性能模式
echo performance  \>  /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
定频设置方法

> 查看当前频率
> 
> cat /proc/msp/pm_cpu
> 
> 设置最大频率为1.2g
> echo 1200000 \> /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
> 
> 设置定频模式
> echo userspace \> /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
> 设置当前频率
> echo 1200000 \> /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed

# 开机trace抓取方式

## 一、常规直接抓取

### 1. /system/etc/init/atrace.rc 打开trace开关

> write /sys/kernel/debug/tracing/tracing_on 1
> 
> write /sys/kernel/tracing/tracing_on 1

### 2.init.rc 添加atrace抓取服务

service boottrace /system/bin/atrace -z -b 20000 gfx input view webview wm am sm audio video camera hal res dalvik rs bionic power pm ss database network adb vibrator aidl pdx sched irq i2c freq idle disk load sync workq memreclaim regulators binder_driver binder_lock -t 30 -o /data/trace.raw
disabled
oneshot
on property:persist.debug.atrace.boottrace=1
start boottrace

## 二、从节点读取信息

### 1. /system/etc/init/atrace.rc 打开trace开关

> write /sys/kernel/debug/tracing/tracing_on 1
> 
> write /sys/kernel/tracing/tracing_on 1

### 2. init.rc 添加一下内容打开相应的节点

```bash
on late-init
chmod 0222 /sys/kernel/debug/tracing/trace_marker
chmod 0222 /sys/kernel/tracing/trace_marker
write /proc/sys/kernel/sched_schedstats 1
chmod 0666 /sys/kernel/debug/tracing/trace_clock
chmod 0666 /sys/kernel/tracing/trace_clock
chmod 0666 /sys/kernel/debug/tracing/buffer_size_kb
chmod 0666 /sys/kernel/tracing/buffer_size_kb
chmod 0666 /sys/kernel/debug/tracing/options/overwrite
chmod 0666 /sys/kernel/tracing/options/overwrite
chmod 0666 /sys/kernel/debug/tracing/options/print-tgid
chmod 0666 /sys/kernel/tracing/options/print-tgid
chmod 0666 /sys/kernel/debug/tracing/saved_cmdlines_size
chmod 0666 /sys/kernel/tracing/saved_cmdlines_size
chmod 0666 /sys/kernel/debug/tracing/events/sched/sched_switch/enable
chmod 0666 /sys/kernel/tracing/events/sched/sched_switch/enable
chmod 0666 /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable
chmod 0666 /sys/kernel/tracing/events/sched/sched_wakeup/enable
chmod 0666 /sys/kernel/debug/tracing/events/sched/sched_blocked_reason/enable
chmod 0666 /sys/kernel/tracing/events/sched/sched_blocked_reason/enable
chmod 0666 /sys/kernel/debug/tracing/events/sched/sched_cpu_hotplug/enable
chmod 0666 /sys/kernel/tracing/events/sched/sched_cpu_hotplug/enable
chmod 0666 /sys/kernel/debug/tracing/events/sched/sched_pi_setprio/enable
chmod 0666 /sys/kernel/tracing/events/sched/sched_pi_setprio/enable
chmod 0666 /sys/kernel/debug/tracing/events/cgroup/enable
chmod 0666 /sys/kernel/tracing/events/cgroup/enable
chmod 0666 /sys/kernel/debug/tracing/events/power/cpu_frequency/enable
chmod 0666 /sys/kernel/tracing/events/power/cpu_frequency/enable
chmod 0666 /sys/kernel/debug/tracing/events/power/cpu_idle/enable
chmod 0666 /sys/kernel/tracing/events/power/cpu_idle/enable
chmod 0666 /sys/kernel/debug/tracing/events/power/clock_set_rate/enable
chmod 0666 /sys/kernel/tracing/events/power/clock_set_rate/enable
chmod 0666 /sys/kernel/debug/tracing/events/power/cpu_frequency_limits/enable
chmod 0666 /sys/kernel/tracing/events/power/cpu_frequency_limits/enable
chmod 0666 /sys/kernel/debug/tracing/events/cpufreq_interactive/enable
chmod 0666 /sys/kernel/tracing/events/cpufreq_interactive/enable
chmod 0666 /sys/kernel/debug/tracing/events/vmscan/mm_vmscan_direct_reclaim_begin/enable
chmod 0666 /sys/kernel/tracing/events/vmscan/mm_vmscan_direct_reclaim_begin/enable
chmod 0666 /sys/kernel/debug/tracing/events/vmscan/mm_vmscan_direct_reclaim_end/enable
chmod 0666 /sys/kernel/tracing/events/vmscan/mm_vmscan_direct_reclaim_end/enable
chmod 0666 /sys/kernel/debug/tracing/events/vmscan/mm_vmscan_kswapd_wake/enable
chmod 0666 /sys/kernel/tracing/events/vmscan/mm_vmscan_kswapd_wake/enable
chmod 0666 /sys/kernel/debug/tracing/events/vmscan/mm_vmscan_kswapd_sleep/enable
chmod 0666 /sys/kernel/tracing/events/vmscan/mm_vmscan_kswapd_sleep/enable
chmod 0666 /sys/kernel/debug/tracing/tracing_on
chmod 0666 /sys/kernel/tracing/tracing_on
chmod 0666 /sys/kernel/debug/tracing/events/binder/binder_transaction/enable
chmod 0666 /sys/kernel/tracing/events/binder/binder_transaction/enable
chmod 0666 /sys/kernel/debug/tracing/events/binder/binder_transaction_received/enable
chmod 0666 /sys/kernel/tracing/events/binder/binder_transaction_received/enable
chmod 0666 /sys/kernel/debug/tracing/events/binder/binder_lock/enable
chmod 0666 /sys/kernel/tracing/events/binder/binder_lock/enable
chmod 0666 /sys/kernel/debug/tracing/events/binder/binder_locked/enable
chmod 0666 /sys/kernel/tracing/events/binder/binder_locked/enable
chmod 0666 /sys/kernel/debug/tracing/events/binder/binder_unlock/enable
chmod 0666 /sys/kernel/tracing/events/binder/binder_unlock/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/enable
chmod 0666 /sys/kernel/tracing/events/i2c/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/i2c_read/enable
chmod 0666 /sys/kernel/tracing/events/i2c/i2c_read/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/i2c_write/enable
chmod 0666 /sys/kernel/tracing/events/i2c/i2c_write/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/i2c_result/enable
chmod 0666 /sys/kernel/tracing/events/i2c/i2c_result/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/i2c_reply/enable
chmod 0666 /sys/kernel/tracing/events/i2c/i2c_reply/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/smbus_read/enable
chmod 0666 /sys/kernel/tracing/events/i2c/smbus_read/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/smbus_write/enable
chmod 0666 /sys/kernel/tracing/events/i2c/smbus_write/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/smbus_result/enable
chmod 0666 /sys/kernel/tracing/events/i2c/smbus_result/enable
chmod 0666 /sys/kernel/debug/tracing/events/i2c/smbus_reply/enable
chmod 0666 /sys/kernel/tracing/events/i2c/smbus_reply/enable
chmod 0666 /sys/kernel/debug/tracing/events/lowmemorykiller/enable
chmod 0666 /sys/kernel/tracing/events/lowmemorykiller/enable
chmod 0666 /sys/kernel/debug/tracing/events/sync/enable
chmod 0666 /sys/kernel/tracing/events/sync/enable
chmod 0666 /sys/kernel/debug/tracing/events/fence/enable
chmod 0666 /sys/kernel/tracing/events/fence/enable
chmod 0666 /sys/kernel/tracing/events/f2fs/f2fs_sync_file_enter/enable
chmod 0666 /sys/kernel/debug/tracing/events/f2fs/f2fs_sync_file_enter/enable
chmod 0666 /sys/kernel/tracing/events/f2fs/f2fs_sync_file_exit/enable
chmod 0666 /sys/kernel/debug/tracing/events/f2fs/f2fs_sync_file_exit/enable
chmod 0666 /sys/kernel/tracing/events/f2fs/f2fs_write_begin/enable
chmod 0666 /sys/kernel/debug/tracing/events/f2fs/f2fs_write_begin/enable
chmod 0666 /sys/kernel/tracing/events/f2fs/f2fs_write_end/enable
chmod 0666 /sys/kernel/debug/tracing/events/f2fs/f2fs_write_end/enable
chmod 0666 /sys/kernel/tracing/events/ext4/ext4_da_write_begin/enable
chmod 0666 /sys/kernel/debug/tracing/events/ext4/ext4_da_write_begin/enable
chmod 0666 /sys/kernel/tracing/events/ext4/ext4_da_write_end/enable
chmod 0666 /sys/kernel/debug/tracing/events/ext4/ext4_da_write_end/enable
chmod 0666 /sys/kernel/tracing/events/ext4/ext4_sync_file_enter/enable
chmod 0666 /sys/kernel/debug/tracing/events/ext4/ext4_sync_file_enter/enable
chmod 0666 /sys/kernel/tracing/events/ext4/ext4_sync_file_exit/enable
chmod 0666 /sys/kernel/debug/tracing/events/ext4/ext4_sync_file_exit/enable
chmod 0666 /sys/kernel/tracing/events/block/block_rq_issue/enable
chmod 0666 /sys/kernel/debug/tracing/events/block/block_rq_issue/enable
chmod 0666 /sys/kernel/tracing/events/block/block_rq_complete/enable
chmod 0666 /sys/kernel/debug/tracing/events/block/block_rq_complete/enable
chmod 0666 /sys/kernel/tracing/events/sde/enable
chmod 0666 /sys/kernel/debug/tracing/events/sde/enable
chmod 0666 /sys/kernel/tracing/events/mdss/enable
chmod 0666 /sys/kernel/debug/tracing/events/mdss/enable
write /sys/kernel/debug/tracing/tracing_on 1
write /sys/kernel/tracing/tracing_on 1
write /sys/kernel/debug/tracing/buffer_size_kb 96000
write /sys/kernel/debug/tracing/events/power/cpu_frequency/enable 1
write /sys/kernel/debug/tracing/events/power/idle/enable 1
write /sys/kernel/debug/tracing/events/sched/sched_switch/enable 1
write /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable 1
write /sys/kernel/debug/tracing/events/block/block_rq_issue/enable 1
write /sys/kernel/debug/tracing/events/block/block_rq_complete/enable 1
chmod 0666 /sys/kernel/debug/tracing/trace
chmod 0666 /sys/kernel/tracing/trace
```

### 3.添加如下属性

debug.atrace.tags.enableflags=802922
persist.traced.enable=0

### 4.开机起来后读取节点信息

cat /sys/kernel/debug/tracing/trace \> /data/trace.out

# 内核增大dmsg信息buffer

/[kernel](http://androidxref.com/kernel_3.18/xref/kernel/)/[printk](http://androidxref.com/kernel_3.18/xref/kernel/printk/)/[printk.c](http://androidxref.com/kernel_3.18/xref/kernel/printk/printk.c)

```c
/kernel/printk/printk.c
old： #define LOG_LINE_MAX		(1024 - PREFIX_MAX)
new：#define LOG_LINE_MAX		(10240 - PREFIX_MAX)
old： #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
new：#define __LOG_BUF_LEN 0x400000
- if(!(devkmsg_log&DEVKMSG_LOG_MASK_ON)){
- 	if(!_ratelimit(&user->rs,current->comm))
- 		return ret;
- }
```

# bootchart的使用

单板上
1\. touch /data/bootchart/enabled
打开开关，重启
2\. tar czf bootchart.tgz \*
进入 /data/bootchart，打包proc_diskstats.log，proc_ps.log，proc_stat.log， header这四个文件为bootchart.tgz
window电脑
3\. java –jar bootchart.jar bootchart.tgz 进入bootchart.jar目录，执行此命令，生成bootchart.png图片

# selinux权限添加

**异常Log:**
type=1400 audit(0.0:282): avc: denied { create } for name="data" scontext=u:r:system_app:s0 tcontext=u:object_r:ctc_file:s0 tclass=dir permissive=0
**分析：**
缺少的权限：{ create }
谁缺少权限：scontext=u:r:system_app:s0
哪个文件的权限：tcontext=u:object_r:ctc_file:s0
文件的类型：tclass=dir
**添加权限：**
allow system_app ctc_file:dir { create };
**目录：**
versionc_p/device/company/project/system/sepolicy/vendor
// 通过线程加速扫描
int iMultitaskNum = SystemProperties.getInt("persist.pm.multitask", 6);

# AndroidP关uboot日志

android 的配置文件里，有GK_BOOT_LOGO_SUPPORT 配置项，之前给kpi 版本做的配置项，可以关掉关闭uboot 的相关打印的。

# Andorid生成core dump文件

1\. echo "/data / %e.%p" \>/proc/sys/kernel/core_pattern
缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。
2\. echo "1" \>/proc/sys/kernel/core_uses_pid
如果被配置成1，那么即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。
3\. ulimit -c unlimited
产生coredump的条件，首先需要确认当前会话的ulimit –c，若为0，则不会产生coredump，需要进行修改和设置。
**116. checkjni优化**
Checkjni功能依赖于属性dalvik.vm.checkjni、ro.kernel.android.checkjni; dalvik.vm.checkjn会覆盖ro.kernel.android.checkjni属性。
dalvik.vm.checkjni默认未定义。
User,Userdebug版本默认关闭，eng版本默认打开（ro.kernel.android.checkjni=1）。

# 查看reserved内存大小

> cat /sys/kernel/debug/memblock/reserved

# 查看/设置apk启动模式

查看
pm dump 包名 | grep status

```
arm: [status=quicken] [reason=first-boot]
    Apk net.sunniwell.service.status:
      Service net.sunniwell.service.status.service.NetworkInfoService:
```

设置
pm compile -m speed –f 包名
或者cmd package compile -m speed –f 包名

```
console:/ # pm compile -m speed tv.icntv.ott                                 
Success
console:/ # pm dump  tv.icntv.ott | grep status                                
      arm: [status=speed] [reason=unknown]
    Apk net.sunniwell.service.status:
      Service net.sunniwell.service.status.service.NetworkInfoService:
```

## dexopt默认优化模式

```
[pm.dexopt.ab-ota]: [speed-profile]
[pm.dexopt.bg-dexopt]: [speed-profile]
[pm.dexopt.boot]: [verify]
[pm.dexopt.first-boot]: [quicken]
[pm.dexopt.inactive]: [verify]
[pm.dexopt.install]: [speed-profile]
[pm.dexopt.priv-apps-oob]: [false]
[pm.dexopt.priv-apps-oob-list]: [ALL]
[pm.dexopt.shared]: [speed]
```

- pm.dexopt.ab-ota: 在 A/B 分区 OTA 更新期间进行优化，可能会使用默认的速度配置。
- pm.dexopt.bg-dexopt: 在后台执行 dex 优化任务时使用的优化策略，可能会使用默认的速度配置。
- pm.dexopt.boot: 在设备引导过程中进行优化，使用检验（verify）模式。
- pm.dexopt.first-boot: 第一次引导时进行优化，采用加速模式（quicken）。
- pm.dexopt.inactive: 在应用程序处于非活动状态时进行优化，使用验证（verify）模式。
- pm.dexopt.install: 在应用程序安装期间进行优化，可能会使用默认的速度配置。
- pm.dexopt.priv-apps-oob: 指定预置系统应用程序是否在出厂时进行优化，默认为 false。
- pm.dexopt.priv-apps-oob-list: 针对哪些预置系统应用程序进行出厂优化，设置为 "ALL" 表示全部预置应用。

# dex2oat编译

apk 编译dex文件
.vdex：其中包含 APK 的未压缩 DEX 代码，以及一些旨在加快验证速度的元数据。
.odex：其中包含 APK 中已经过 AOT 编译的方法代码。
ROM编译配置，
1、BroadConfig.mk配置
WITH_DEXPREOPT := true
\# 对系统映像上安装的 DEX 代码调用 dex2oat
WITH_DEXPREOPT_BOOT_IMG_AND_SYSTEM_SERVER_ONLY := false
\#对启动类路径和系统服务，JAR，apk等 进行dex文件 编译优化
2、第三方无源码apk 在 Android.mk 中指定 include \$(BUILD_PREBUILT) 预构建apk 编译生成dex文件
参考：

```shell
include \$(CLEAR_VARS)
LOCAL_MODULE := test
LOCAL_SRC_FILES := test.apk
ALL_DEFAULT_INSTALLED_MODULES := \$(LOCAL_MODULE)
LOCAL_MODULE_PATH := \$(TARGET_OUT_APPS)
LOCAL_MODULE_CLASS := APPS
LOCAL_CERTIFICATE := PRESIGNED
LOCAL_PROPRIETARY_MODULE := false
include \$(BUILD_PREBUILT)
```

编译后dex文件生成在，代码out路径system/app/xxx.apk/oat/arm/

# 横竖屏切换

setprop persist.prop.screenorientation portrait 竖屏
setprop persist.prop.screenorientation landscape 横屏

# 显示dpi修改

settings put secure display_density_forced 240
settings get secure display_density_forced

# 查看apk版本信息

dumpsys package ctc.android.smart.terminal.iptv \| egrep "versionCode\|versionName"

# 查看cpu中断

硬中断 cat /proc/interrupts
软中断cat /proc/softirqs

# c++标准库函数名冲突解决办法

![image48-20251225151645-yunjwf8.png](https://mrlove.oss-cn-chengdu.aliyuncs.com/images/20251225175758796.png)

# 调整网络中断与网络吞吐量

echo 20971520 \> /proc/sys/net/core/rmem_max
设置 Linux 系统中**每个套接字的最大接收缓冲区大小**（单位：字节）。
echo 20971520 \> /proc/sys/net/core/rmem_default
设置 Linux 系统中**每个套接字的默认接收缓冲区大小**（单位：字节）。
echo  4 \> /proc/irq/103/smp_affinity
设置**中断号 103 对应的硬件中断的 CPU 亲和性**。
echo f \> /sys/class/net/eth0/queues/rx-0/rps_cpus

- **作用**：设置 eth0 第 0 个接收队列的**RPS 流哈希表大小**。
- 数值含义：32768 表示哈希表的条目数，决定了系统能同时跟踪的 “网络流” 数量。
- 说明：RPS 通过哈希算法（基于源 IP、目的 IP、端口等信息）识别不同的网络流，并将同一流的数据包分发到同一个 CPU 核心，保证数据包的顺序性。这个参数越大，能跟踪的流越多，分流效果越好，但会占用更多内核内存。
  echo 32768 \>/sys/class/net/eth0/queues/rx-0/rps_flow_cnt
- **作用**：设置 eth0 第 0 个接收队列的**RPS 流哈希表大小**。
- 数值含义：32768 表示哈希表的条目数，决定了系统能同时跟踪的 “网络流” 数量。
- 说明：RPS 通过哈希算法（基于源 IP、目的 IP、端口等信息）识别不同的网络流，并将同一流的数据包分发到同一个 CPU 核心，保证数据包的顺序性。这个参数越大，能跟踪的流越多，分流效果越好，但会占用更多内核内存。
  echo 23768 \> /proc/sys/net/core/rps_sock_flow_entries
- **作用**：设置**系统全局的 RPS 套接字流条目数上限**。
- 说明：这个参数限制了所有 CPU 核心上 RPS 能管理的套接字流总数，需要和 rps_flow_cnt 配合设置，避免单个队列的流条目数超过全局上限。

