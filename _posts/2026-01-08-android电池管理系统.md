---
layout: post
title: android电池管理系统
date: 2026-01-08 15:20:00 +0800
author: Mrlove
categories: [HMI, android, linux,battery]
description: 电池管理系统
keywords: 电池, battery, android电池管理系统, android battery management system
tags: [HMI, android, linux,battery]
---
# 1.整体架构

Android的电池架构包括从顶层用户使用App需要调用的电池相关的**Android sdk api**到最底层的硬件驱动，分别涉及到**Android Framework**、**Android HAL**和**Linux Kernel Driver**这几个部分。
本文基于基于**Android 8.1**系统，**Rockchip**平台进行分析，其中对于硬件平台的电源驱动移植或者电源驱动编写，其主要关心的部分还是**Linux Kernel Driver**，这个部分，通常需要实现**charger**单元和电量计这两个部分的功能。整体的架构简单整理了一下如下图所示；

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108152825975.png)

# 2.android 电池服务

Android电池服务，用来监听内核上报的电池事件，并将最新的电池数据上报给系统，系统收到新数据后会去更新电池显示状态、剩余电量等信息。如果收到过温报警和低电报警，系统会自动触发关机流程，保护电池和机器不受到危害。
Android电池服务的启动和运行流程：

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108153357033.png)

```
Android电池服务的源码结构
         Framework\base\services\java\com\android\server
        ├── SystemServer.java
                 创建BatteryServices、PowerManagerService、ActivityManagerService
        ├── BatterySevices.java
                 监听底层上报的battery事件，广播电池发生改变的消息
         Framework\base\services\java\com\android\server\am
        ├── ActivityManagerService.java
                 创建BatteryStatsService
        ├── BatteryStatsService.java
                 统计和记录电池参数的信息
         Framework\base\services\java\com\android\server\power
        ├── PowerManagerService.java
                 监听电池发生变化的广播消息，并调节系统的电源状态，例如亮屏
         Framework\base\core\java\com\internal\os\
        ├── BatteryStatsImpl.java
                 统计和记录电池参数的信息，并通知其他模块
         System\core\healthd
        ├── healthd.cpp
                 创建uevent socket，监听内核上报的内核事件
        ├── BatteryMonitor.cpp
                 初始化本地电池数据结构，将power_supply路径下属性节点路径填充进去，
        ├── BatteryMonitor.h
        ├── BatteryPropertiesRegistrar.cpp
                 创建电池属性监听器，并将其注册到Android的系统服务中
        ├── BatteryPropertiesRegistrar.h
```

# 3.hal进程Healthd

电池系统从底层向Framework层上报数据的流程：

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108153944845.png)

下面分析下详细代码：

Healthhd实际就是对应于batteryservice的hal进程，源码路径下 `system/core/healthd。`

## 3.1. 基础架构

首先看到安卓源码路径下的`health`，文件列表如下所示；

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108155711625.png)

主要是通过`BatteryMonitor.cpp`中的`bool BatteryMonitor::update(void)`函数上报信息，其中，内核首先会更新数据到`/sys/class/power_supply/battery`节点下各个属性，这个在上一个小节有做解释，先来看一下整体的架构。
该模型向下监听来自底层的电池事件，向上传递电池数据信息给Framework层的BatteryService用来计算电池电量相关信息，BatteryService通过传递来的数据来计算电池电量等信息，因此healthd在电池管理系统中起着承上启下的作用。

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108155819630.png)

这幅图片再一次把整体的数据走向具体化，可以看到主要负责工作的是`BatteryMonitor`，主要分析一下该文件中的`init`和`update`就可以搞清楚大部分的问题。

## 3.1. init

下面是init（）函数的具体实现；

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108161111942.png)
![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108161219695.png)

在这个函数中，我们可以清楚地看到，对于battery下每一个属性，在init函数中都会提前获取到相应的路径，然后再去读取属性值去做对应的更新，这里通过update函数进行上报。

## 3.3. update

update函数具体实现如下；

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108161614882.png)

## 3.4. 其他主要代码

health模块的代码位置位于/system/core/healthd/,其入口在Healthd.cpp中的main函数中：

```c
healthd_mode_ops = &android_ops;  //开机充电时初始化结构体
healthd_mode_ops = &charger_ops;  //关机充电时初始化结构体
```

healthd_mode_ops是一个充电状态的结构体，正常开机情况下会 将android_ops结构体赋值给healthd_mode_ops ，如果在关机情况下会将 charget_ops结构体赋值给healthd_mode_opos，就是关机充电的使用。
然后在healthd_init中，主要做一些初始化工作，并且创建了一个epoll,主要用于将文件指针挂在工作队列中，用于轮询查看驱动层是否发来信息，然后调用uevent_init()对uevent进行注册，应为从上篇文章我们明白，电池驱动是通过uevent与health进行通信的，uevent通信本质上就是socket通信。

> epollfd = epoll_create(MAX_EPOLL_EVENTS);

初始化之后，执行healthd_mainloop()，开启了一个无线循环，监听是否有uevent事件到来，如果在for循环中检测到uevent事件到来的时候，会直接调用 uevent_event函数
在uevent_event函数中，会判断SSUBSYSTEM是否等于POWER_SUPPLY_SUBSYSTEM,如果是的话，说明是电池驱动传过来的信息，会执行healthd_battery_update()函数。在该函数中会直接调用BatteryMonitor中的update()函数,对电池的各个属性进行更新，并在最后调用在前面注册的监听进行上报。
在update()函数中调用 healthd_mode_ops->battery_update(&props) 进行，其中battery_update(&props)为在health.cpp中初始化的结构体，最后返回当前的充电状态。
battery_update()调用的函数如下，调用注册的监听进行上报：

```c
    void healthd_mode_android_battery_update(struct android::BatteryProperties *props) {
      if (gBatteryPropertiesRegistrar != NULL)
         gBatteryPropertiesRegistrar->notifyListeners(*props); //调用监听并传入属性值
      return;
   }
```

接着gBatteryPropertiesRegistrar 这个监听就会回调在framwork层实现的函数，然后通过Binder机制向上层通信.

# 4. 内核电源管理框架

## power_supply子系统介绍

Android电源管理底层用的是**Linux power_supply**框架，内核提供给电池驱动的接口是结构体**power_supply**结构体。
内核主要通过**get_property**这个函数指针来获得驱动中的有关电池的信息，而这个函数在内核中只给出了声明，我们在写驱动的时候要自己实现这个函数，即将自己写的函数赋值给这个函数指针，当内核需要驱动中电源信息的时候就回调这个**get_property**函数.抽象出来的各类信息称为**property**，比如供电设备是否连接就对应着**POWER_SUPPLY_PROP_ONLINE**
另外，我们写驱动程序的时候又要给用户提供接口，内核中提供给用户的接口就是sysfs，通过读取sysfs文件系统中文件内容，就可以得到电源的信息。**power_supply**子系统是kernel用来管理所有与电池有关的设备，包括充电放电，电池安全情况等等信息。话不多说，直接从宏观到微观的深入了解。

## 4.1.1. power_supply注册设备节点

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108173356686.png)

对应供电设备类型：

```c
ANDROID_POWER_SUPPLY_TYPE_AC //交流电充电，比如通过电源适配器链接。
ANDROID_POWER_SUPPLY_TYPE_USB //usb口充电设备，比如通过电脑的usb口充电
ANDROID_POWER_SUPPLY_TYPE_BATTERY //电池设备
```

实际还支持**ANDROID_POWER_SUPPLY_TYPE_WIRELESS**无线充电类型。
ac和usb只创建了一个online属性，上层通过判断ac和usb的online状态（1表示设备接入，0表示设备拔出）便可知道当前系统是由什么设备在充电了；而battery则创建了如status、health、present、capacity、batt_vol等等和电池相关的诸多属性，上层通过这些电池属性uevent便可监控电池的当前工作状态了。
可以发现当前注册了3个power_supply，那么它是怎么注册的呢？

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108173603071.png)

反注册：

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108173618567.png)

两者都是注册power_supply子系统的，后者的注册表示不用的时候会自动释放。其中我们需要实现的参数有 struct power_supply_desc *desc 和 struct power_supply_config *cfg。第一个参数是设备的parent，直接传&pdev->dev即可。接下来分析一下后面两个参数。

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108180040353.png)

简单明显的在代码中描述，现在讲重点， psy属性。它其实就是一个枚举的参数，如果需要设置什么属性就枚举什么，由于枚举的参数很多就提几个重点讲一下。看代码注释。

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108180102309.png)

属性的节点存在了，那么他是怎么上报到应用层的呢？当然是通过回调函数去设置（set_property）或者读取（get_property）属性值啦.是通过一个switch去选择不同属性的参数，至于上报的参数需要自己设置或者算法去获取。提供了get_property的示例。

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108180118768.png)

回归到第一个注册函数的第三个参数 struct power_supply_config \*cfg。

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108180131866.png)

## 4.1.2. power_supply向应用层上报

当 power_supply更新状态时，调用power_supply_changed函数通知应用层。届时等待应用层调用回调函数进行 power_supply的设置或者获取。
power_supply_changed是内核power_supply提供的原生API。

1. 驱动调用power_supply_changed通知内核；
2. 内核power_supply_sysfs.c和power_supply_core.c调用驱动register的函数列表读取电源信息，写入/sys/class/powersupply节点。
3. 用户态hal进程从/sys/class/powersupply下的节点读取数据

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108195617889.png)

## 4.1.3 power_supply代码分析

### 基础框架

**power supply class** 位于drivers/power/目录中，主要由3部分组成（可参考下图的软件架构）：
**power supply core** 用于抽象核心数据结构、实现公共逻辑。位于drivers/power/power_supply_core.c中。
**power supply sysfs** 实现sysfs以及uevent功能。位于drivers/power/power_supply_sysfs.c中。
**power supply leds** 基于linux led class，提供PSY设备状态指示的通用实现。位于drivers/power/power_suppply_leds.c中。
根据以上的结构并在内核成功注册之后，会在sysfs系统中注册以下节点ac,battery,usb，如下图所示：

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108195713014.png)

进入battery路径下可以发现很多文件，如下图所示：

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108195732144.png)

这里是系统为了方便调试，可以读取这些文件的内容，这些大多数内容可以在Linux内核源码/kernel/include/power_supply.h中查阅到，下面做个简单介绍：

> [!Tip]
> capacity：当前电池容量
> charge_full：充满电的电池容量
> temp：电池温度
> uevent：上报uevent需要用到的数据
> charge_counter：充电次数
> current_now：当前充电电流
> health status：电池健康状态，包括cold，hot ,Good等
> technology：电池类型，包括锂电池，镍铬电池等等
> voltage_now：当前电池电压

这里拿ac作为例子来解释一下如何进行power_supply的注册，总共分为四个部分：

1. 根据硬件特定的情况，确定psy设备具备哪些特性，哪些数据需要上报，并把他们和enum power_supply_property对应；
2. 根据实际的情况，去实现这些properties的get/set的接口，具体参考bq24296_charge_usb_get_property函数的实现；
3. 定义一个struct power_supply_desc变量，并初始化必要成员后，调用devm_power_supply_register将其注册到kernel中；
4. 根据实际情况，启动设备属性变化的监控函数，可以使用中断，轮询等，并在发生改变时，调用power_supply_changed，通知power suopply core，具体可以参考bq24296_charge_set_chrg_param。

### 实现可以支持的属性读取

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108195944689.png)

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108195955626.png)

### 注册驱动

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108200026096.png)

### 通知变化

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108200047103.png)

## 4.1.4. 驱动

电池的各种状态以及充电的状态信息如何从内核空间上报到用户空间。通俗的讲就是如何从内核驱动将各种状态数据上报到Android层。Android系统与传统Linux不同，对于内核空间和用户空间的数据交互，并不再使用udev的机制，而是使用了uevent的方式 ①，当电池状态发生变化，可以实时更新到用户空间，具体的数据架构如下图所示；

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108200115910.png)

在驱动层，主要是两大模块，与电池相关的驱动和与充放电管理相关的驱动（对应图中的battery.c和charger.c）,这两大模块主要处理硬件相关的逻辑，在硬件状态发生变化时，会触发相关的中断，驱动层会调用相应的中断函数，并更新修改相应的psy节点值。

这一节给出实例，讲解如何实现linux内核充电模块驱动，供参考：

### 4.1.4.1. Charger.ko

Charger 驱动需要完成以下几个工作，并上报给用户空间：

- Charger IC的初始化；
- 设备电源的插入和拔出检测；
- 设备电源类型的检测：ac(dcp),dc,usb(cdp,sdp)
- 充放电电流的设置；
  - 充电四个阶段：涓流，恒流，恒压，截止
  - 放电：过放检测，NTC补偿等等；
- 当前充电状态的查询，包括未充电，充电，充满等等，这个需要预留接口，电量计驱动会使用到；
- 注册ac，usb这两个power supply类用于数据上报；

在这里，Charger在实际工作中还需要完成的任务还有很多，这里暂时不一一列举了，详细参考Charger 驱动源码解析 。

### 4.1.4.2. Battery.ko

电量计驱动需要完成很大一部分的工作，电量计实现比较复杂，这里简单列举一下：

- 充电曲线平滑算法；
- 放电曲线平滑算法；
- 电池基本信息上报，包括电池容量，充放电状态，电池百分比等等；

# 5. 总结

一个电池充放电管理关键还是在于如何检测是否正在充电，是否充满电，这个需要配合硬件，以上的API函数可以控制电池的充电和放电上报，你可以通过AD脚检测电池的电压，设置一个定时器去模拟电池充放电管理的过程，并且通过两个IO口，读取IO口的电平值判断电池是否充满电，是否正在充电，这样可以达到充放电的管理过程。

> 查看电池是否注册了
> cat /sys/class/power_supply/ xxx //xxx 为注册的名字
> 电池的属性
> cat /sys/class/power_supply/test_battery //里面有子系统的属性值

# 6. 其他

## 6.1. 常用属性和节点

![](https://gitee.com/Mrlove/NoteImages/raw/master/images/20260108200811589.png)

### 6.1.1. 当前的充电电流与电压：

Max charging current: 500000（微安）
Max charging voltage: 5000000（微伏）
Charge counter: 2238960（瞬时电池容量 uA-h）
//\* 当以上两者相乘是会得到其充电功率，上层软件以此基础确定当前是否为慢/快速充电。
SettingsLib 下的BatteryStatus.java

```java
    final int maxChargingMicroAmp = batteryChangedIntent.getIntExtra(EXTRA_MAX_CHARGING_CURRENT, -1);
    int maxChargingMicroVolt = batteryChangedIntent.getIntExtra(EXTRA_MAX_CHARGING_VOLTAGE, -1);
    if (maxChargingMicroVolt <= 0) {
        maxChargingMicroVolt = DEFAULT_CHARGING_VOLTAGE_MICRO_VOLT;
    }
    if (maxChargingMicroAmp > 0) {
        // Calculating muW = muA * muV / (10^6 mu^2 / mu); splitting up the divisor
        // to maintain precision equally on both factors.
        maxChargingWattage = (maxChargingMicroAmp / 1000)
                * (maxChargingMicroVolt / 1000);
    } else {
        maxChargingWattage = -1;
    }
/**
 * Return current chargin speed is fast, slow or normal.
 *
 * @return the charing speed
 */
public final int getChargingSpeed(Context context) {
    final int slowThreshold = context.getResources().getInteger(
            R.integer.config_chargingSlowlyThreshold);
    final int fastThreshold = context.getResources().getInteger(
            R.integer.config_chargingFastThreshold);
    return maxChargingWattage <= 0 ? CHARGING_UNKNOWN :
            maxChargingWattage < slowThreshold ? CHARGING_SLOWLY :
                    maxChargingWattage > fastThreshold ? CHARGING_FAST :
                            CHARGING_REGULAR;
}
```

SettingsLib下的config.xml有快慢充电的值，如下：

```xml
<!-- Threshold in micro watts below which a charger is rated as "slow"; 1A @ 5V -->
<integer name="config_chargingSlowlyThreshold">5000000</integer>

<!-- Threshold in micro watts above which a charger is rated as "fast"; 1.5A @ 5V  -->
<integer name="config_chargingFastThreshold">7500000</integer>
```

对应节点：

```language
/sys/class/power_supply/%s/current_max
/sys/class/power_supply/%s/voltage_max
/sys/class/power_supply/battery/charge_counter
```

### 6.1.2. 电池状态

status: 2

BatteryManager.BATTERY_STATUS_UNKNOWN = 1
BatteryManager.BATTERY_STATUS_CHARGING = 2
BatteryManager.BATTERY_STATUS_DISCHARGING = 3

BatteryManager.BATTERY_STATUS_NOT_CHARGING = 4 //\*电池不充电-有充电器时的特殊情况，但电池不充电
BatteryManager.BATTERY_STATUS_FULL = 5

对应节点：

/sys/class/power_supply/battery/status

### 6.1.3. 电池健康状态

health: 2

BatteryManager.BATTERY_HEALTH_UNKNOWN = 1
BatteryManager.BATTERY_HEALTH_GOOD = 2
BatteryManager.BATTERY_HEALTH_OVERHEAT = 3
BatteryManager.BATTERY_HEALTH_DEAD = 4
BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE = 5
BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE = 6 //\*蓄电池出现未知/未指定的FID故障。
BatteryManager.BATTERY_HEALTH_COLD = 7

对应节点：

/sys/class/power_supply/battery/health

### 6.1.4. 电池瞬时电量

level: 76

剩余电池容量百分比

对应节点：

/sys/class/power_supply/battery/capacity

### 6.1.5. 电池瞬时电压

voltage: 4111（毫伏）

瞬时电池电压，以毫伏 (mV) 为单位

对应节点：

/sys/class/power_supply/battery/voltage_now

### 6.1.6. 电池瞬时温度

temperature: 268

以摄氏度为单位的瞬时电池温度

对应节点：

/sys/class/power_supply/battery/temp

## 6.2. 无电池设备工作原理

本页将介绍 Android 如何应对具有可拆卸电池或无内置电池的产品。无内置电池设备会改为连接到外部电源，例如其他设备上的交流电源插座或 USB 端口。

- 是否有电池？
  应用可以使用以下代码来检测设备当前是否有电池：

```java
final Intent batteryInfo = registerReceiver(null, new
IntentFilter(Intent.ACTION_BATTERY_CHANGED));

return batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);
```

- Android 9 及更高版本

Android 9 针对无电池设备移除了一些以前的代码；这类设备在默认情况下假定电池存在，充电率为 100%，运行状况良好，且热敏电阻温度读数正常。
处理这项信息的大多数框架 API 会继续像以前那样处理常见情况：系统将被视为“正在充电”（即未使用电池电量运行），且不会被视为电量不足。如果界面上显示有电池图标，则它会附带一个英文感叹号，电量百分比将显示为 0%。但是设备不会因电池电量不足而关闭，而且需要充电或需要电池电量充足的作业也会予以安排。
如上所述，Android 9 原始代码可在您的设备上正常运行，但建议您对内核或 HAL 进行更改，以准确反映产品的电源和电池状态。如果 Android 9 及更高版本未检测到 Linux power supply 类充电器设备，在默认情况下，所有充电器类型（交流、USB、无线）的状态都将为“离线”。如前所述，如果所有充电器都处于离线状态，但未检测到电池设备，系统仍会被视为“正在充电”，也就是说，系统正在使用外部电源（而不是电池电量）运行。
如果您的产品没有电池，且始终连接到电源，那么，您最好针对交流电源或 USB 电源（其在线 sysfs 属性会设置为 true）实现 Linux 内核 power_supply 类充电器驱动程序。或者，您也可以在 Health HAL 中为设备配置交流充电器在线属性。为此，请按照实现 Health 2.0 中的说明实现 Health HAL。
此自定义 Health HAL 会实现 Health::getHealthInfo() 的自定义版本，而该版本会修改 BatteryProperties.chargerAcOnline = true 的值。
首先，请将文件 hardware/interfaces/health/2.0/default/Health.cpp 复制到您自己的 Health HAL 实现中，并根据 Health 2.0 README 对其进行修改。
